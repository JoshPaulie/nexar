{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nexar","text":"<p>Dead simple League of Legend API lookups. Match history, solo/flex queue ranks, champion performance stats, all in a few lines of code.</p> <p>Async, pythonic, built-in rate limiting &amp; disk caching.</p> <p>Quick start</p>"},{"location":"#inspiration","title":"Inspiration","text":"<p>Nexar was created because I wanted the following from my League wrapper, particularly for my friend group's discord bot:</p> <ul> <li>Simple summoner and match lookups (like op.gg)</li> <li>League centric</li> <li>Basic rate limiting</li> <li>Caching</li> <li>Type hinted</li> <li>High level objects with methods like <code>.get_matches()</code>, and be returned actual Python objects</li> </ul>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#what-is-a-puuid","title":"What is a PUUID?","text":"<p>A Player Universally Unique Identifier (PUUID) is a unique string associated with a Riot account. They are always 78 characters long.</p> <p>With the introduction of Riot IDs, Summoner IDs were deprecated. The PUUID is now the primary lookup key for most API endpoints.</p> <p>Note</p> <p>PUUIDs are encrypted per API key.</p> <p>This means the same user will have different PUUIDs depending on which API key is used to retrieve them.</p> <p>Generally, this does not affect typical usage. However, you cannot look up a user's PUUID with one API key and then use that PUUID as input with a different API key.</p>"},{"location":"FAQ/#why-do-i-have-to-provide-2-regions","title":"Why do I have to provide 2 regions?","text":"<p>Under the hood, Nexar is of course making API calls to various Riot endpoints. Some are using \"V4\" regions, while newer are using \"V5\" regions. Each endpoint uses a different \"version\" region.</p> <p>Despite none of the endpoints ever using both the region versions, Nexar's <code>Player</code> object makes calls with methods which may use one or the other. Thus, both need set when defining a player.</p>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#the-client","title":"The client","text":"<p>The primary object for Nexar is the <code>NexarClient</code>.</p> <p>Here you set your Riot API key, pick a cache type (if any), and optionally set default regions(1) for your lookups.</p> <ol> <li>Helpful for personal projects, where you're only pulling stats for yourself and friends.</li> </ol> StandardWith default regionsWith smart cache <pre><code>from nexar.client import NexarClient\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n)\n</code></pre> <pre><code>from nexar.client import NexarClient\nfrom nexar.enums import Region\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n    default_region=Region.NA1,\n)\n</code></pre> <pre><code>from nexar.cache import SMART_CACHE_CONFIG\nfrom nexar.client import NexarClient\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n    cache_config=SMART_CACHE_CONFIG,\n)\n</code></pre> <p>You can use the client in a couple of ways, but the most common will be:</p> <pre><code>import asyncio\n\n# .. client declaration from above\n\n\nasync def main() -&gt; None:\n    async with client:\n        ...\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Note</p> <p>All of the following examples will implicitly be done inside of this declared <code>async with client</code> context.</p> <p>Snippets will also be de-indented for easier reading.</p>"},{"location":"quick_start/#player","title":"<code>Player</code>","text":"<p>The \"heavylifter\" model is <code>Player</code>. <code>Player</code> encapsulates multiple endpoints and allows you to elegantly make API calls and derive values without having to combine the output of many datapoints.</p> <p>Read the full <code>Player</code> docs here</p>"},{"location":"quick_start/#getting-players","title":"Getting players","text":"<p>To start, we either import Player and pass it our client, or use <code>NexarClient.get_player()</code>.</p> <pre><code>from nexar.models import Player\n\n# Get player with default region set in client\nplayer = await client.get_player(\"bexli\", \"bex\")\n# or\nplayer = await Player.by_riot_id(client, \"bexli#bex\")\n# or\nplayer = await Player.create(client, \"bexli\", \"bex\")\n\n# Get a player from a different region\neu_player = await client.get_player(\n    \"Thebausffs\",\n    \"COOL\",\n    region=Region.EUW1,\n)\n</code></pre> <p>You can even get multiple Players at a time(1):</p> <ol> <li>Though, they must be of the same region.</li> </ol> <pre><code>players = await client.get_players([\"bexli#bex\", \"mltsimpleton#na1\"])\n\n# Iterate over players\nfor player in players:\n    # Get player summoner info\n    player_summoner = await player.get_summoner()\n    # Print player summoner level\n    print(f\"{player.game_name} is level {player_summoner.summoner_level}\")\n</code></pre>"},{"location":"quick_start/#using-player","title":"Using <code>Player</code>","text":"<p><code>Player</code> has quite a few convenience methods, like:</p> Current ranked standings<pre><code># Solo queue\nsolo_rank = await player.get_solo_rank()\n\nif solo_rank:\n    solo_tier = solo_rank.tier  # RankTier.Bronze, RankTier.Iron, ...\n    solo_division = solo_rank.tier  # RankDivision.IV, RankDivision.III, ...\n    solo_league_points = solo_rank.league_points\n\n# Flex queue\nsolo_rank = await player.get_flex_rank()\n\n# Of course, all of the same properties as Solo queue\n</code></pre> Recent match history<pre><code>from nexar.enums import Queue\n\n# Get player's last match\nlast_match = await player.get_last_match()\n\n# Get player's recent draft pick matches\nlast_10_draft_matches = await player.get_matches(\n    count=10,\n    queue=Queue.DRAFT_PICK,\n)\n</code></pre> Champion performance<pre><code># Get recent champion performance from matches\nrecent_champion = last_10_draft_matches.get_champion_stats()\nif recent_champion:\n    for stat in recent_champion:\n        print(f\"Average KDA with {stat.champion_name}: {stat.avg_kda:.2f}\")\n        # Output: (1)\n</code></pre> <ol> <li> <pre><code>Average KDA with Jinx: 2.91\nAverage KDA with Jhin: 3.25\nAverage KDA with Lillia: 2.09\nAverage KDA with Warwick: 2.09\nAverage KDA with Ashe: 2.50\n</code></pre> </li> </ol>"},{"location":"quick_start/#match","title":"<code>Match</code>","text":"<p>Another powerful model is <code>Match</code>, particularly in combination with <code>Participant</code> &amp; <code>ParticipantList</code>.</p> <pre><code>last_match = await player.get_last_match()\nassert last_match\n\nstart_time = last_match.info.game_start_timestamp\ndays_ago = (datetime.now(tz=UTC) - start_time).days\nprint(f\"{player.game_name}'s last game was {days_ago} day(s) ago\")\n</code></pre>"},{"location":"quick_start/#participant","title":"<code>Participant</code>","text":"<p>The difference between <code>Player</code> and <code>Participant</code> might be confusing.</p> <p>A \"participant\" is 1 of 10 players (in a Summoner's Rift game, more or less for other modes). Attached to the <code>Participant</code> is all of the stats related to that player over the duration of the game.</p> <pre><code>participants = last_match.participants\nwinning_team = participants.winners()\n\nwinner_names = \", \".join([p.game_name or \"Unknown\" for p in winning_team])\nprint(f\"Winners! {winner_names}\\n\")\n\nfor p in participants:\n    name = p.game_name\n    champ_name = p.champion_name\n    kda = p.kda(as_str=True)\n    print(f\"{name} ({champ_name}) went {kda}\")\n\n# Output: (1)\n</code></pre> <ol> <li> <pre><code>Winners! Mojo Jo 77, Bravo, GAMr Guy, bexli, MltSimpleton\n\nFugginSuggin (Darius) went 2/9/1\nHeckenGena (Belveth) went 3/7/4\nCauris (Annie) went 2/12/8\nSupremeKing (Jinx) went 14/7/4\nVillain King (Karma) went 2/6/10\nMojo Jo 77 (Mordekaiser) went 12/4/3\nBravo (Amumu) went 9/3/6\nGAMr Guy (Xerath) went 5/6/11\nbexli (Jhin) went 11/6/8\nMltSimpleton (Senna) went 4/4/19\n</code></pre> </li> </ol>"},{"location":"quick_start/#participantlist","title":"<code>ParticipantList</code>","text":"<p>The easiest way to get a particular participant from a <code>Match</code> is using the very helpful <code>ParticipantList</code>, which is what is returned by <code>Match.participants</code>.</p>"},{"location":"quick_start/#get-participants","title":"Get participant(s)","text":"<pre><code># Get participant by PUUID (easiest is from Player.puuid)\nparticipant = participants.by_puuid(player.puuid)\n\n# Get participants by position\nfrom nexar.enums import MatchParticipantPosition as Position\n\nbot_participants = participants.by_position(Position.BOTTOM)\n\n# Get participants by champion (Not recommended, prone to typos)\njinx_players = participants.by_champion(\"Jinx\")\n</code></pre> <p>Afterwhich we can dig into the stats</p> <pre><code># Typical stats\nmagic_damage = participant.magic_damage_dealt_to_champions\ncs = participant.creep_score\ndrags = participant.dragon_kills\n\n# The really fun stuff\nassert participant.challenges\nbuffs_stolen = participant.challenges.buffs_stolen\ngold_per_min = participant.challenges.gold_per_minute\n</code></pre>"},{"location":"quick_start/#get-team","title":"Get team","text":"<p>You can also easily get a particular team from a Match.</p> <pre><code># Get blue team\nblue_team = participants.blue_team()\n\n# Get red team\nred_team = participants.red_team()\n\n# Get team of particular player\nteam_of_player = participants.team_of(player.puuid)\n</code></pre>"},{"location":"why-not-nexar/","title":"Why not Nexar?","text":"<p>At this time, Nexar is intended for personal projects, as the rate limiter is simple, and I'm unsure how it work at scale.</p>"},{"location":"why-not-nexar/#infancy","title":"Infancy","text":"<p>Project is very new and functionality is well suited for my usecases.</p> <p>Issues are encouraged for features I haven't thought of.</p>"},{"location":"why-not-nexar/#simplicity","title":"Simplicity","text":"<p>There's really nothing magic going on.</p> <p>We're just using <code>aiohttp</code> to make async API calls, <code>aiolimiter</code> to stagger requests, then using the <code>aiohttp-client-cache</code> to save responses.</p> <ul> <li>Need the cache in a different format?</li> <li>Need some sort of middleware?</li> <li>Need a \"production ready\" solution?</li> <li>Need different rate limits for different endpoints?</li> </ul> <p>Nexar is not for you.</p>"},{"location":"why-not-nexar/#its-only-league-of-legends","title":"It's only League of Legends","text":"<p>Particularly League players and matches, of all game types.</p> <p>No other Riot games will be supported, including \"Teamfight Tactics\".</p> <p>Any TFT related issues or requests will be laughed at and closed.</p>"},{"location":"why-not-nexar/#more-sdk-than-wrapper","title":"More SDK than wrapper","text":"<p>Nexar doesn't completely cover all League related endpoints, at least not yet. The goal of the project is stat pulling, particularly summoner and match history.</p>"},{"location":"why-not-nexar/#comparing-nexar-to-related-libraries","title":"Comparing Nexar to related libraries","text":"Library Async/sync Wrapper only Caching Rate limiting Active dev Nexar  Async  No  SQLite, in-memory   Simple Pulsefire  Async  Yes  Many solutions   Precise Cassiopeia  Sync  No  In-memory<sup>1</sup>  Precise RiotWatcher  Sync  Yes  None  Naive Pyot  Async  No  Many solutions  Precise <p>Pulsefire is the recommended Nexar alternative. Async, type safe, idiomatic and completley wraps all Riot Games APIs.</p> <p>Nexar was created as a simpler (and \"League only\") Pulsefire alternative, focusing on developer experience (helper functions, robust models, doc strings galore, and usage examples). It's heavily inspired by Pulsefire's predicate library, Pyot.</p> <p>Nexar is no where near production ready, while Pulsefire is.</p> <ol> <li> <p>An disk caching plugin package is available\u00a0\u21a9</p> </li> </ol>"},{"location":"client-features/caching/","title":"Caching in Nexar","text":"<p>Tip</p> <p>This is a bit of a more advanced topic, involving the actual under the hood API calls to Riot, which Nexar tries to hide from the user.</p> <p>By and large, simply use the SMART_CACHE_CONFIG: <pre><code>from nexar.client import NexarClient\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n)\n</code></pre></p> <p>This keeps a local, persistent storage of data to reduce API calls.</p> <p>Nexar includes built-in caching functionality to reduce API calls and improve performance. Cached responses are either stored locally (sqlite file) or in memory, and reused until they expire.</p> <p>Via <code>CacheConfig</code>, one can specify a default cache time, pick your storage backend, and configure endpoint TTLs (time-to-live's).</p>"},{"location":"client-features/caching/#quick-start","title":"Quick Start","text":"<p>By default, Nexar uses \"dumb\" caching, which caches all responses for an hour to an SQLite file in your CWD, regardless of the endpoint:</p> <pre><code>import asyncio\n\nfrom nexar.client import NexarClient\nfrom nexar.enums import Region\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n    default_region=Region.NA1,\n)\n\n\nasync def main() -&gt; None:\n    async with client:\n        # First call hits the API\n        player = await client.get_player(\"bexli\", \"bex\")\n\n        # Second call uses cached data\n        player = await client.get_player(\"bexli\", \"bex\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"client-features/caching/#cache-backends","title":"Cache Backends","text":"<p>Nexar supports two cache backends:</p> <ul> <li>SQLite (default): Persistent cache stored in a file</li> </ul> <pre><code>from nexar.cache import SMART_CACHE_CONFIG\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n    cache_config=SMART_CACHE_CONFIG,\n    default_region=Region.NA1,\n)\n</code></pre> <ul> <li>Memory: Fast in-memory cache (cleared when application exits)</li> </ul> <pre><code>from nexar.cache import SMART_CACHE_CONFIG_MEMORY\n\nclient = NexarClient(\n    riot_api_key=\"your_api_key\",\n    cache_config=SMART_CACHE_CONFIG_MEMORY,\n    default_region=Region.NA1,\n)\n</code></pre>"},{"location":"client-features/caching/#custom-cache-configuration","title":"Custom Cache Configuration","text":"<p>Note</p> <p>For creating your own endpoint config, consult the Riot API docs</p> <p>You can create your own cache configuration, and set things like the path to your database file or a custom endpoint durations, etc.</p> <pre><code>from nexar import CacheConfig\n\n# SQLite cache with custom settings\ncustom_config = CacheConfig(\n    backend=\"sqlite\",\n    cache_dir=\"/var/cache/nexar/\",\n    expire_after=7200,  # Default 2 hours\n    endpoint_config={\n        \"/riot/account/v1/accounts/by-riot-id\": {\"expire_after\": None},  # Never cache Riot ID\n    },\n)\n\n# Memory cache with custom expiration\nmemory_config = CacheConfig(\n    backend=\"memory\",\n    expire_after=900,  # 15 minutes\n)\n</code></pre> <p>On, even easier, use the same endpoint config as the \"smart\" presets </p> <pre><code>from nexar.cache import SMART_CACHE_ENDPOINTS\n\n# SQLite cache with custom settings\ncustom_config = CacheConfig(\n    backend=\"sqlite\",\n    cache_dir=\"./my_cache\",\n    endpoint_config=SMART_CACHE_ENDPOINTS,\n)\n\n# Memory cache with custom expiration\nmemory_config = CacheConfig(\n    backend=\"memory\",\n    endpoint_config=SMART_CACHE_ENDPOINTS,\n)\n</code></pre>"},{"location":"client-features/caching/#predefined-configurations","title":"Predefined Configurations","text":""},{"location":"client-features/caching/#default_cache_config","title":"DEFAULT_CACHE_CONFIG","text":"<p>Uses SQLite backend with 1-hour expiration for all endpoints.</p>"},{"location":"client-features/caching/#smart_cache_configsmart_cache_config_memory","title":"SMART_CACHE_CONFIG/SMART_CACHE_CONFIG_MEMORY","text":"<p>Intelligently caches different endpoint types for optimal durations:</p> <ul> <li>Account/Summoner data: 24 hours (rarely changes)</li> <li>Match data: Forever (matches are immutable)</li> <li>League entries: 5 minutes (rankings change frequently)  </li> <li>Match IDs: 1 minute (new matches appear)</li> </ul>"},{"location":"client-features/caching/#memory_cache_config","title":"MEMORY_CACHE_CONFIG","text":"<p>Uses in-memory caching with 30-minute expiration.</p>"},{"location":"client-features/caching/#no_cache_config","title":"NO_CACHE_CONFIG","text":"<p>Disables caching entirely - every request hits the API.</p>"},{"location":"client-features/caching/#cache-management","title":"Cache Management","text":"<pre><code>async with NexarClient(riot_api_key=\"your_api_key\") as client:\n    # Get cache information\n    info = await client.get_cache_info()\n\n    # Clear cached data\n    await client.clear_cache()\n\n    # View API call statistics\n    client.print_api_call_summary()\n</code></pre>"},{"location":"client-features/caching/#best-practices","title":"Best Practices","text":"<ol> <li>Use SMART_CACHE_CONFIG for most applications</li> <li>Use memory backend for short-lived scripts or when you don't want persistent files</li> <li>Customize expiration times based on how frequently your data changes</li> <li>Disable caching for specific endpoints that need real-time data</li> </ol>"},{"location":"client-features/debug-responses/","title":"Debug API Responses","text":"<p>The Nexar client includes a debug feature that allows you to inspect API responses as they are returned from the Riot Games API. This is useful for development, troubleshooting, and understanding the structure of API responses.</p>"},{"location":"client-features/debug-responses/#enabling-debug-output","title":"Enabling Debug Output","text":"<p>To enable debug output, set the <code>NEXAR_DEBUG_RESPONSES</code> environment variable to any non-empty value:</p> <pre><code>export NEXAR_DEBUG_RESPONSES=1\n</code></pre> <p>Or in Python:</p> <pre><code>import os\nos.environ[\"NEXAR_DEBUG_RESPONSES\"] = \"1\"\n</code></pre>"},{"location":"client-features/debug-responses/#debug-output-format","title":"Debug Output Format","text":"<p>When enabled, the debug feature will print detailed information about each API response:</p> <pre><code>============================================================\nDEBUG: API Response for /riot/account/v1/accounts/by-riot-id/bexli/bex\nURL: https://americas.api.riotgames.com/riot/account/v1/accounts/by-riot-id/bexli/bex\nStatus: 200\nFrom Cache: True\nParams: {\"count\": 10, \"queue\": 420}\nResponse Data:\n{\n  \"puuid\": \"0wKS4sQQTcA6mAmu_oW5rVhyxmWAXV9hZrraXnDdh8GvelgGWYM5tM7fcHw0kalBVgCl6MxOZe0bLA\",\n  \"gameName\": \"bexli\",\n  \"tagLine\": \"bex\"\n}\n============================================================\n</code></pre> <p>The debug output includes:</p> <ul> <li>Endpoint: The API endpoint path that was called</li> <li>URL: The full URL including region</li> <li>Status: HTTP status code of the response</li> <li>From Cache: Whether the response was served from cache or was a fresh API call</li> <li>Params: Query parameters sent with the request (if any)</li> <li>Response Data: The full JSON response from the API, formatted for readability</li> </ul>"},{"location":"client-features/rate-limiting/","title":"Rate Limiting","text":"<p>Nexar includes built-in rate limiting to ensure your application complies with Riot's API rate limits and avoids getting rate limited.</p> <p>Note</p> <p>If the rate limit is met, and a Retry-After is provided by Riot, Nexar will simply wait the small duration and continue.</p>"},{"location":"client-features/rate-limiting/#default-rate-limits","title":"Default Rate Limits","text":"<p>By default, Nexar enforces the following rate limits:</p> <ul> <li>20 requests per 1 second</li> <li>100 requests per 2 minutes</li> </ul> <p>These are the standard Riot API limits for most personal applications.</p>"},{"location":"client-features/rate-limiting/#basic-usage","title":"Basic Usage","text":"<p>Rate limiting is enabled automatically when you create a <code>NexarClient</code>:</p> <pre><code># Rate limiting is automatically applied to all API calls\naccount = await client.get_riot_account(\"bexli\", \"bex\")\n</code></pre>"},{"location":"client-features/rate-limiting/#custom-rate-limits","title":"Custom Rate Limits","text":"<p>You can configure custom rate limits if needed:</p> <pre><code>client_custom_limits = NexarClient(\n    riot_api_key=api_key,\n    default_region=Region.NA1,\n    per_second_limit=(1, 1),  # Max of 1 request per second\n    per_minute_limit=(10, 5),  # Max of 10 requests per 5 minutes\n)\nasync with client_custom_limits:\n    # Use client here\n    pass\n</code></pre>"},{"location":"client-features/rate-limiting/#how-it-works","title":"How It Works","text":"<p>Nexar automatically enforces Riot's API rate limits by sleeping between calls, using the strictest of the two provided rate limits. Additionally, <code>aiolimiter</code> library to aid with <code>asyncio.gather</code> calls<sup>1</sup>.</p> <p>Cached responses do not count against rate limits.</p>"},{"location":"client-features/rate-limiting/#logging","title":"Logging","text":"<p>The rate limiter provides detailed logging to help you understand its behavior. You can configure logging levels using <code>configure_logging</code>.</p>"},{"location":"client-features/rate-limiting/#example-log-output","title":"Example Log Output","text":"<pre><code>[nexar] Rate limiter initialized with 2 limits:\n[nexar]   Limit 1: 20 requests per 1s\n[nexar]   Limit 2: 100 requests per 120s\n[nexar] Limit 1: 19/20 used, 1 remaining\n[nexar] Limit 2: 45/100 used, 55 remaining\n[nexar] Rate limit hit! Limit 1 (20 req/1s) - waiting 0.85 seconds\n[nexar] Rate limit wait complete - proceeding with request\n</code></pre>"},{"location":"client-features/rate-limiting/#rate-limiting-vs-caching","title":"Rate Limiting vs Caching","text":"<p>Rate limiting and caching work together intelligently:</p> <ol> <li>Cached responses don't count against rate limits since no actual API request is made</li> <li>Fresh requests are subject to rate limiting to ensure compliance with Riot's limits</li> <li>Cache hits are instant and don't consume any rate limit quota</li> <li>Cache misses trigger rate limiting before making the actual API call</li> </ol> <p>This means you can make the same API call repeatedly without worrying about rate limits if the response is cached. Only unique requests or expired cache entries will consume your rate limit quota.</p>"},{"location":"client-features/rate-limiting/#example","title":"Example","text":"<pre><code># First call - fresh request, counts against rate limits\naccount = await client.get_riot_account(\"bexli\", \"bex\")  # Rate limited if needed\n\n# Subsequent calls - cached, no rate limiting\naccount = await client.get_riot_account(\"bexli\", \"bex\")  # Instant, no rate limit check\naccount = await client.get_riot_account(\"bexli\", \"bex\")  # Instant, no rate limit check\n\n# Different account - fresh request, rate limited\nother = await client.get_riot_account(\"Doublelift\", \"NA1\")  # Rate limited if needed\n</code></pre> <ol> <li> <p>With limited success in testing\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/batch_players/","title":"Batch player retrieval","text":"<p><code>NexarClient.get_players()</code> is an efficient way of getting fetching many players in parallel</p> <pre><code># List of riot IDs to fetch\nriot_ids = [\n    \"bexli#bex\",\n    \"mltsimpleton#na1\",\n]\n\nprint(f\"Fetching {len(riot_ids)} players...\")\n\n# Fetch all players in parallel\nplayers = await client.get_players(riot_ids)\n\nprint(f\"Successfully retrieved {len(players)} players!\\n\")\n</code></pre> <p><code>NexarClient.get_players()</code> also takes regional arguments</p> <pre><code>riot_ids_korean: list[str] = []  # Imagine this is populated with Korean players\n\nplayers_korean = await client.get_players(\n    riot_ids_korean,\n    region=Region.KR,\n)\n</code></pre>"},{"location":"examples/champ_performance/","title":"Champ performance","text":"<pre><code># Get player\nplayer = await client.get_player(\"bexli\", \"bex\")\n\n# Get recent matches\nmatches = await player.get_matches()\n\nchamp_performance = matches.get_champion_stats()\nfor champ in champ_performance:\n    print(champ.champion_name)\n    print(f\"{champ.wins} wins / {champ.losses} losses ({champ.win_rate:.2g}%)\")\n    kda = f\"{champ.avg_kills:.2g}/{champ.avg_deaths:.2g}/{champ.avg_assists:.2g}\"\n    print(f\"Average KDA: {kda} ({champ.avg_kda:.2g})\\n\")\n</code></pre>"},{"location":"examples/champ_performance/#available-stats","title":"Available stats","text":"<pre><code>champion_id: int\nchampion_name: str\ngames_played: int\nwins: int\nlosses: int\ntotal_kills: int\ntotal_deaths: int\ntotal_assists: int\nwin_rate: float\navg_kda: float\navg_kills: float\navg_deaths: float\navg_assists: float\n</code></pre>"},{"location":"examples/match_history/","title":"Match History","text":"<p>Get a Player's recent match history, with filters like queue time, dates, and count.</p> <pre><code># Get player\nplayer = await client.get_player(\"bexli\", \"bex\")\n\n# Get last 20 matches\nmatches = await player.get_matches()\n\n# Get last 5 solo queue matches\nmatches = await player.get_matches(count=5, queue=Queue.SOLO_QUEUE)\n\n# Get last week's matches\npast_week = dt.datetime.now(tz=dt.UTC) - dt.timedelta(days=7)\npast_week_matches = await player.get_matches(start_time=past_week)\n\n# Get last match\nlast_match = await player.get_last_match()\n</code></pre>"},{"location":"examples/player_performance/","title":"Player performance","text":"<pre><code># Get player\nplayer = await client.get_player(\"bexli\", \"bex\")\n\n# Get recent matches\nmatches = await player.get_matches(count=20)\n\n# Get recent performance stats\nperformance = matches.get_performance_stats()\n\nprint(f\"Performance over {performance.total_games} recent games:\")\nprint(f\"Win Rate: {performance.win_rate:.1f}% ({performance.wins}W/{performance.losses}L)\")\n\nkda_str = f\"{performance.avg_kills:.1f}/{performance.avg_deaths:.1f}/{performance.avg_assists:.1f}\"\nprint(f\"Average KDA: {kda_str} ({performance.avg_kda:.2f})\")\nprint(f\"Average CS: {performance.avg_cs:.1f}\")\nprint(f\"Average Game Duration: {performance.avg_game_duration_minutes:.1f} minutes\")\n</code></pre>"},{"location":"examples/player_performance/#available-stats","title":"Available stats","text":"<pre><code>total_games: int\nwins: int\nlosses: int\nwin_rate: float\navg_kills: float\navg_deaths: float\navg_assists: float\navg_kda: float\navg_cs: float\navg_game_duration_minutes: float\n</code></pre>"},{"location":"examples/soft_players_by_rank/","title":"Sort players by rank","text":"<p>The <code>utils</code> modules provides a function which takes a list of players and returns a new list of the same players, but sorted</p> <pre><code># Get players\nriot_ids = [\n    \"bexli#bex\",\n    \"mltsimpleton#na1\",\n    \"roninalex#na1\",\n    \"poydok#na1\",\n    \"boxrog#na1\",\n    \"vynle#na1\",\n]\n\nprint(f\"Fetching {len(riot_ids)} players...\\n\")\n\n# Fetch all players in parallel\nplayers = await client.get_players(riot_ids)\n\n# Players sorted by rank\nsorted_players = await sort_players_by_rank(players)\n\n# Print them!\nfor player in sorted_players:\n    solo_rank = await player.get_solo_rank()\n    rank_text = (\n        f\"{solo_rank.tier} {solo_rank.division:&lt;3} ({solo_rank.league_points} LP)\"\n        if solo_rank  # Handle unranked\n        else \"Unranked!\"\n    )\n    print(f\"{player.game_name:&lt;12} :: {rank_text}\")\n</code></pre>"},{"location":"reference/client/","title":"Client","text":"<p>Main client for the Nexar SDK.</p>"},{"location":"reference/client/#nexar.client.NexarClient","title":"<code>NexarClient</code>","text":"<p>Client for interacting with the Riot Games API.</p> Source code in <code>nexar/client.py</code> <pre><code>class NexarClient:\n    \"\"\"Client for interacting with the Riot Games API.\"\"\"\n\n    # --------------------------------------------------------------------------\n    # Initialization and Lifecycle\n    # --------------------------------------------------------------------------\n\n    def __init__(\n        self,\n        riot_api_key: str,\n        default_region: Region | None = None,\n        cache_config: CacheConfig | None = None,\n        per_second_limit: tuple[int, int] = (20, 1),\n        per_minute_limit: tuple[int, int] = (100, 2),\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Nexar client.\n\n        Args:\n            riot_api_key: Your Riot Games API key\n            default_region: Default region for API calls\n            cache_config: Cache configuration (uses default if None)\n            per_second_limit: Tuple of (max_requests, seconds). E.g., (20, 1) for max 20 requests per 1 second.\n            per_minute_limit: Tuple of (max_requests, minutes). E.g., (100, 2) for max 100 requests per 2 minutes.\n\n        \"\"\"\n        self.riot_api_key = riot_api_key\n        self.default_region = default_region\n        self.cache_config = cache_config or DEFAULT_CACHE_CONFIG\n        self._per_second_limit = per_second_limit\n        self._per_minute_limit = per_minute_limit\n        self.rate_limiter = RateLimiter(\n            per_second_limit=self._per_second_limit,\n            per_minute_limit=self._per_minute_limit,\n        )\n        self._logger = get_logger()\n        self._api_call_count = 0\n        self._session: CachedSession | aiohttp.ClientSession | None = None\n\n    async def __aenter__(self) -&gt; \"NexarClient\":\n        \"\"\"Async context manager entry.\"\"\"\n        await self._ensure_session()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the client session.\"\"\"\n        if self._session and not self._session.closed:\n            await self._session.close()\n\n    # --------------------------------------------------------------------------\n    # Public API Methods\n    # --------------------------------------------------------------------------\n\n    # Account API\n    async def get_riot_account(\n        self,\n        game_name: str,\n        tag_line: str,\n        region: Region | None = None,\n    ) -&gt; RiotAccount:\n        \"\"\"\n        Get a Riot account by game name and tag line.\n\n        Args:\n            game_name: The game name (without #)\n            tag_line: The tag line (without #)\n            region: Region to use (defaults to client's default)\n\n        Returns:\n            RiotAccount with account information\n\n        \"\"\"\n        resolved_region = self._resolve_region(region)\n        endpoint = f\"/riot/account/v1/accounts/by-riot-id/{game_name}/{tag_line}\"\n        data = await self._make_api_call(endpoint, resolved_region.account_region)\n        return RiotAccount.from_api_response(data)\n\n    # Summoner API\n    async def get_summoner_by_puuid(self, puuid: str, region: Region | None = None) -&gt; Summoner:\n        \"\"\"\n        Get a summoner by PUUID.\n\n        Args:\n            puuid: The summoner's PUUID\n            region: Region to use (defaults to client's default)\n\n        Returns:\n            Summoner with summoner information\n\n        \"\"\"\n        resolved_region = self._resolve_region(region)\n        endpoint = f\"/lol/summoner/v4/summoners/by-puuid/{puuid}\"\n        data = await self._make_api_call(endpoint, resolved_region.value)\n        return Summoner.from_api_response(data)\n\n    # League API\n    async def get_league_entries_by_puuid(\n        self,\n        puuid: str,\n        region: Region | None = None,\n    ) -&gt; list[LeagueEntry]:\n        \"\"\"\n        Get league entries by PUUID.\n\n        Args:\n            puuid: The summoner's PUUID\n            region: Region to use (defaults to client's default)\n\n        Returns:\n            List of league entries for the summoner\n\n        \"\"\"\n        resolved_region = self._resolve_region(region)\n        endpoint = f\"/lol/league/v4/entries/by-puuid/{puuid}\"\n        data = await self._make_api_call(endpoint, resolved_region.value)\n        entries_list: list[dict[str, Any]] = data  # type: ignore[assignment]\n        return [LeagueEntry.from_api_response(entry) for entry in entries_list]\n\n    # Match API\n    async def get_match(self, match_id: str, region: Region | None = None) -&gt; Match:\n        \"\"\"\n        Get match details by match ID.\n\n        Args:\n            match_id: The match ID\n            region: Region to use (defaults to client's default)\n\n        Returns:\n            Match with detailed match information\n\n        \"\"\"\n        resolved_region = self._resolve_region(region)\n        endpoint = f\"/lol/match/v5/matches/{match_id}\"\n        data = await self._make_api_call(endpoint, resolved_region.v5_region)\n        return Match.from_api_response(data)\n\n    async def get_match_ids_by_puuid(\n        self,\n        puuid: str,\n        *,\n        start_time: int | datetime | None = None,\n        end_time: int | datetime | None = None,\n        queue: Queue | int | None = None,\n        match_type: MatchType | str | None = None,\n        start: int = 0,\n        count: int = 20,\n        region: Region | None = None,\n    ) -&gt; list[str]:\n        \"\"\"\n        Get match IDs by PUUID with optional filters.\n\n        Args:\n            puuid: The player's PUUID\n            start_time: Epoch timestamp in seconds or datetime for match start filter\n            end_time: Epoch timestamp in seconds or datetime for match end filter\n            queue: Queue ID filter (int or QueueId enum)\n            match_type: Match type filter (str or MatchType enum)\n            start: Start index (0-based)\n            count: Number of match IDs to return (0-100)\n            region: Region to use (defaults to client's default)\n\n        Returns:\n            List of match IDs\n\n        \"\"\"\n        if not 0 &lt;= count &lt;= MAX_MATCH_ID_COUNT:\n            msg = f\"count must be between 0 and {MAX_MATCH_ID_COUNT}\"\n            raise ValueError(msg)\n\n        resolved_region = self._resolve_region(region)\n        params = self._build_match_ids_params(start_time, end_time, queue, match_type, start, count)\n        endpoint = f\"/lol/match/v5/matches/by-puuid/{puuid}/ids\"\n        data = await self._make_api_call(endpoint, resolved_region.v5_region, params=params)\n        match_ids: list[str] = data  # type: ignore[assignment]\n        return match_ids\n\n    # --------------------------------------------------------------------------\n    # High-Level Convenience Methods\n    # --------------------------------------------------------------------------\n\n    async def get_player(\n        self,\n        game_name: str,\n        tag_line: str,\n        region: Region | None = None,\n    ) -&gt; \"Player\":\n        \"\"\"\n        Create a Player object for convenient high-level access.\n\n        Args:\n            game_name: Player's game name (without #)\n            tag_line: Player's tag line (without #)\n            region: The player's region (defaults to client default)\n\n        Returns:\n            Player object providing high-level access to player data\n\n        \"\"\"\n        from .models.player import Player\n\n        resolved_region = self._resolve_region(region)\n\n        return await Player.create(\n            client=self,\n            game_name=game_name,\n            tag_line=tag_line,\n            region=resolved_region,\n        )\n\n    async def get_players(\n        self,\n        riot_ids: list[str],\n        region: Region | None = None,\n    ) -&gt; list[\"Player\"]:\n        \"\"\"\n        Create multiple Player objects efficiently using parallel processing.\n\n        Args:\n            riot_ids: List of Riot IDs in \"username#tagline\" format.\n            region: The players' region (defaults to client default)\n\n        Returns:\n            List of Player objects.\n\n        \"\"\"\n        from .models.player import Player\n\n        resolved_region = self._resolve_region(region)\n\n        async def create_player(riot_id: str) -&gt; Player:\n            return await Player.by_riot_id(\n                client=self,\n                riot_id=riot_id,\n                region=resolved_region,\n            )\n\n        return await asyncio.gather(*[create_player(riot_id) for riot_id in riot_ids])\n\n    # --------------------------------------------------------------------------\n    # Public Utility Methods\n    # --------------------------------------------------------------------------\n\n    # Caching\n    async def clear_cache(self) -&gt; None:\n        \"\"\"Clear all cached responses.\"\"\"\n        if isinstance(self._session, CachedSession) and self._session.cache:\n            await self._session.cache.clear()\n            self._logger.log_cache_cleared()\n\n    async def get_cache_info(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get information about the current cache state.\n\n        Returns:\n            Dictionary with cache statistics and configuration.\n\n        \"\"\"\n        info = {\n            \"enabled\": self.cache_config.enabled,\n            \"backend\": self.cache_config.backend,\n            \"cache_name\": self.cache_config.cache_name,\n            \"default_expire_after\": self.cache_config.expire_after,\n            \"cached_responses\": 0,\n        }\n\n        if isinstance(self._session, CachedSession) and self._session.cache:\n            try:\n                cache = self._session.cache\n                if hasattr(cache, \"__len__\"):\n                    info[\"cached_responses\"] = len(cache)\n                if hasattr(cache, \"size\"):\n                    info[\"cache_size\"] = cache.size\n            except (AttributeError, KeyError, TypeError) as exc:\n                self._logger.logger.debug(\"Cache info check failed: %s\", exc)\n\n        return info\n\n    # Stats and Rate Limiting\n    def get_api_call_stats(self) -&gt; dict[str, int]:\n        \"\"\"Get API call statistics.\"\"\"\n        return self._logger.get_stats()\n\n    def print_api_call_summary(self) -&gt; None:\n        \"\"\"Print a summary of API calls made so far.\"\"\"\n        self._logger.log_stats_summary()\n\n    def reset_rate_limiter(self) -&gt; None:\n        \"\"\"Reset the rate limiter state to the initial configuration.\"\"\"\n        self.rate_limiter = RateLimiter(\n            per_second_limit=self._per_second_limit,\n            per_minute_limit=self._per_minute_limit,\n        )\n\n    # --------------------------------------------------------------------------\n    # Internal Methods\n    # --------------------------------------------------------------------------\n\n    # Session Management\n    async def _ensure_session(self) -&gt; None:\n        \"\"\"Ensure the session is created and configured.\"\"\"\n        if self._session and not self._session.closed:\n            return\n\n        if self.cache_config.enabled:\n            urls_expire_after = {\n                f\"*{pattern}*\": config.get(\"expire_after\", self.cache_config.expire_after)\n                for pattern, config in self.cache_config.endpoint_config.items()\n                if isinstance(config, dict) and config.get(\"enabled\", True)\n            }\n            self._session = CachedSession(\n                cache=create_cache_backend(self.cache_config),\n                urls_expire_after=urls_expire_after or None,\n            )\n        else:\n            self._session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30))\n\n        self._setup_caching()\n\n    def _setup_caching(self) -&gt; None:\n        \"\"\"Set up caching for the HTTP session if enabled.\"\"\"\n        if not self.cache_config.enabled:\n            return\n\n        has_cache = isinstance(self._session, CachedSession) and self._session.cache is not None\n        cache_type = type(self._session.cache) if has_cache and isinstance(self._session, CachedSession) else None\n\n        self._logger.log_cache_setup(\n            cache_name=self.cache_config.cache_name,\n            backend=self.cache_config.backend,\n            has_cache=has_cache,\n            cache_type=cache_type,\n        )\n\n        if has_cache and isinstance(self._session, CachedSession) and self.cache_config.expire_after is not None:\n            self._logger.log_cache_config(\n                expire_after=self.cache_config.expire_after,\n                has_url_expiration=bool(getattr(self._session, \"urls_expire_after\", None)),\n            )\n\n    # Core API Call Logic\n    async def _make_api_call(\n        self,\n        endpoint: str,\n        region_value: str,\n        params: dict[str, Any] | None = None,\n        max_retries: int = 5,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Make an async API call, handling rate limits, retries, and caching.\"\"\"\n        url = f\"https://{region_value}.api.riotgames.com{endpoint}\"\n        headers = {\"X-Riot-Token\": self.riot_api_key}\n\n        for _ in range(max_retries):\n            await self._ensure_session()\n            if not self._session:\n                msg = \"Client session not initialized.\"\n                raise RuntimeError(msg)\n\n            self._api_call_count += 1\n            self._logger.log_api_call_start(self._api_call_count, endpoint, region_value, params)\n\n            try:\n                # Try cache lookup\n                if isinstance(self._session, CachedSession) and self._session.cache:\n                    cache_key = self._session.cache.create_key(\"GET\", url, params=params, headers=headers)\n                    cached_response = await self._session.cache.get_response(cache_key)\n                    if cached_response:\n                        response_data: dict[str, Any] = await cached_response.json()\n                        self._logger.log_api_call_success(cached_response.status, from_cache=True)\n                        self._debug_print_response(\n                            endpoint=endpoint,\n                            url=url,\n                            status=cached_response.status,\n                            from_cache=True,\n                            response_data=response_data,\n                            params=params,\n                        )\n                        return response_data\n\n                # Perform HTTP request\n                async with (\n                    self.rate_limiter.combined_limiters(),\n                    self._session.get(\n                        url,\n                        headers=headers,\n                        params=params,\n                    ) as response,\n                ):\n                    if response.status == HTTP_TOO_MANY_REQUESTS:\n                        retry_after = response.headers.get(\"Retry-After\")\n                        wait_time = float(retry_after) if retry_after else 120.0\n                        self._logger.logger.warning(\"Rate limited (429). Retrying in %s seconds...\", wait_time)\n                        await asyncio.sleep(wait_time)\n                        continue  # Retry\n\n                    await self._handle_response_errors(response)\n                    response_data = await response.json()\n                    from_cache = getattr(response, \"from_cache\", False)\n                    self._logger.log_api_call_success(response.status, from_cache=from_cache)\n                    self._debug_print_response(\n                        endpoint=endpoint,\n                        url=url,\n                        status=response.status,\n                        from_cache=from_cache,\n                        response_data=response_data,\n                        params=params,\n                    )\n                    return response_data\n\n            except aiohttp.ClientError as e:\n                self._logger.log_api_call_error(e)\n                raise RiotAPIError(0, f\"Request failed: {e}\") from e\n            except RiotAPIError as e:\n                self._logger.log_api_call_error(e)\n                raise\n\n        msg = \"Max retries exceeded for rate-limited request.\"\n        raise RiotAPIError(HTTP_TOO_MANY_REQUESTS, msg)\n\n    async def _handle_response_errors(self, response: aiohttp.ClientResponse) -&gt; None:\n        \"\"\"Raise appropriate exceptions for HTTP error status codes.\"\"\"\n        if response.ok:\n            return\n\n        try:\n            error_data = await response.json()\n            message = error_data.get(\"status\", {}).get(\"message\", \"Unknown error\")\n        except (ValueError, aiohttp.ContentTypeError):\n            message = await response.text() or f\"HTTP {response.status}\"\n\n        error_map = {\n            HTTP_UNAUTHORIZED: UnauthorizedError,\n            HTTP_FORBIDDEN: ForbiddenError,\n            HTTP_NOT_FOUND: NotFoundError,\n            HTTP_TOO_MANY_REQUESTS: RateLimitError,\n        }\n        error_class = error_map.get(response.status, RiotAPIError)\n        raise error_class(response.status, message)\n\n    # Parameter Building and Resolution\n    def _build_match_ids_params(\n        self,\n        start_time: int | datetime | None,\n        end_time: int | datetime | None,\n        queue: Queue | int | None,\n        match_type: MatchType | str | None,\n        start: int,\n        count: int,\n    ) -&gt; dict[str, int | str]:\n        \"\"\"Build the query parameter dictionary for the get_match_ids_by_puuid endpoint.\"\"\"\n        params: dict[str, int | str] = {}\n        if start_time is not None:\n            params[\"startTime\"] = int(start_time.timestamp()) if isinstance(start_time, datetime) else start_time\n        if end_time is not None:\n            params[\"endTime\"] = int(end_time.timestamp()) if isinstance(end_time, datetime) else end_time\n        if queue is not None:\n            params[\"queue\"] = queue.value if isinstance(queue, Queue) else queue\n        if match_type is not None:\n            params[\"type\"] = match_type.value if isinstance(match_type, MatchType) else match_type\n        if start != 0:\n            params[\"start\"] = start\n        if count != DEFAULT_MATCH_ID_COUNT:\n            params[\"count\"] = count\n        return params\n\n    def _resolve_region(self, region: Region | None) -&gt; Region:\n        \"\"\"Resolve the region, using the client's default if None.\"\"\"\n        resolved_region = region or self.default_region\n        if resolved_region is None:\n            msg = \"A region must be provided either as a default or as an argument.\"\n            raise ValueError(msg)\n        return resolved_region\n\n    # Debugging and Stats\n    def _debug_print_response(\n        self,\n        endpoint: str,\n        url: str,\n        status: int,\n        *,\n        from_cache: bool,\n        response_data: dict[str, Any],\n        params: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Print API response for debugging if NEXAR_DEBUG_RESPONSES is set.\"\"\"\n        if not os.getenv(\"NEXAR_DEBUG_RESPONSES\"):\n            return\n\n        print(f\"\\n{'=' * 60}\")\n        print(f\"DEBUG: API Response for {endpoint}\")\n        print(f\"URL: {url}\")\n        print(f\"Status: {status}\")\n        print(f\"From Cache: {from_cache}\")\n        if params:\n            print(f\"Params: {params}\")\n        print(\"Response Data:\")\n        print(json.dumps(response_data, indent=2))\n        print(f\"{'=' * 60}\\n\")\n\n    def _get_api_call_count(self) -&gt; int:\n        \"\"\"Get the current number of API calls made.\"\"\"\n        return self._api_call_count\n\n    def _reset_api_call_count(self) -&gt; None:\n        \"\"\"Reset the API call counter to zero.\"\"\"\n        self._api_call_count = 0\n        self._logger.reset_stats()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>nexar/client.py</code> <pre><code>async def __aenter__(self) -&gt; \"NexarClient\":\n    \"\"\"Async context manager entry.\"\"\"\n    await self._ensure_session()\n    return self\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>nexar/client.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.__init__","title":"<code>__init__(riot_api_key, default_region=None, cache_config=None, per_second_limit=(20, 1), per_minute_limit=(100, 2))</code>","text":"<p>Initialize the Nexar client.</p> <p>Parameters:</p> Name Type Description Default <code>riot_api_key</code> <code>str</code> <p>Your Riot Games API key</p> required <code>default_region</code> <code>Region | None</code> <p>Default region for API calls</p> <code>None</code> <code>cache_config</code> <code>CacheConfig | None</code> <p>Cache configuration (uses default if None)</p> <code>None</code> <code>per_second_limit</code> <code>tuple[int, int]</code> <p>Tuple of (max_requests, seconds). E.g., (20, 1) for max 20 requests per 1 second.</p> <code>(20, 1)</code> <code>per_minute_limit</code> <code>tuple[int, int]</code> <p>Tuple of (max_requests, minutes). E.g., (100, 2) for max 100 requests per 2 minutes.</p> <code>(100, 2)</code> Source code in <code>nexar/client.py</code> <pre><code>def __init__(\n    self,\n    riot_api_key: str,\n    default_region: Region | None = None,\n    cache_config: CacheConfig | None = None,\n    per_second_limit: tuple[int, int] = (20, 1),\n    per_minute_limit: tuple[int, int] = (100, 2),\n) -&gt; None:\n    \"\"\"\n    Initialize the Nexar client.\n\n    Args:\n        riot_api_key: Your Riot Games API key\n        default_region: Default region for API calls\n        cache_config: Cache configuration (uses default if None)\n        per_second_limit: Tuple of (max_requests, seconds). E.g., (20, 1) for max 20 requests per 1 second.\n        per_minute_limit: Tuple of (max_requests, minutes). E.g., (100, 2) for max 100 requests per 2 minutes.\n\n    \"\"\"\n    self.riot_api_key = riot_api_key\n    self.default_region = default_region\n    self.cache_config = cache_config or DEFAULT_CACHE_CONFIG\n    self._per_second_limit = per_second_limit\n    self._per_minute_limit = per_minute_limit\n    self.rate_limiter = RateLimiter(\n        per_second_limit=self._per_second_limit,\n        per_minute_limit=self._per_minute_limit,\n    )\n    self._logger = get_logger()\n    self._api_call_count = 0\n    self._session: CachedSession | aiohttp.ClientSession | None = None\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.clear_cache","title":"<code>clear_cache()</code>  <code>async</code>","text":"<p>Clear all cached responses.</p> Source code in <code>nexar/client.py</code> <pre><code>async def clear_cache(self) -&gt; None:\n    \"\"\"Clear all cached responses.\"\"\"\n    if isinstance(self._session, CachedSession) and self._session.cache:\n        await self._session.cache.clear()\n        self._logger.log_cache_cleared()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the client session.</p> Source code in <code>nexar/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the client session.\"\"\"\n    if self._session and not self._session.closed:\n        await self._session.close()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_api_call_stats","title":"<code>get_api_call_stats()</code>","text":"<p>Get API call statistics.</p> Source code in <code>nexar/client.py</code> <pre><code>def get_api_call_stats(self) -&gt; dict[str, int]:\n    \"\"\"Get API call statistics.\"\"\"\n    return self._logger.get_stats()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_cache_info","title":"<code>get_cache_info()</code>  <code>async</code>","text":"<p>Get information about the current cache state.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with cache statistics and configuration.</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_cache_info(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get information about the current cache state.\n\n    Returns:\n        Dictionary with cache statistics and configuration.\n\n    \"\"\"\n    info = {\n        \"enabled\": self.cache_config.enabled,\n        \"backend\": self.cache_config.backend,\n        \"cache_name\": self.cache_config.cache_name,\n        \"default_expire_after\": self.cache_config.expire_after,\n        \"cached_responses\": 0,\n    }\n\n    if isinstance(self._session, CachedSession) and self._session.cache:\n        try:\n            cache = self._session.cache\n            if hasattr(cache, \"__len__\"):\n                info[\"cached_responses\"] = len(cache)\n            if hasattr(cache, \"size\"):\n                info[\"cache_size\"] = cache.size\n        except (AttributeError, KeyError, TypeError) as exc:\n            self._logger.logger.debug(\"Cache info check failed: %s\", exc)\n\n    return info\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_league_entries_by_puuid","title":"<code>get_league_entries_by_puuid(puuid, region=None)</code>  <code>async</code>","text":"<p>Get league entries by PUUID.</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The summoner's PUUID</p> required <code>region</code> <code>Region | None</code> <p>Region to use (defaults to client's default)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[LeagueEntry]</code> <p>List of league entries for the summoner</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_league_entries_by_puuid(\n    self,\n    puuid: str,\n    region: Region | None = None,\n) -&gt; list[LeagueEntry]:\n    \"\"\"\n    Get league entries by PUUID.\n\n    Args:\n        puuid: The summoner's PUUID\n        region: Region to use (defaults to client's default)\n\n    Returns:\n        List of league entries for the summoner\n\n    \"\"\"\n    resolved_region = self._resolve_region(region)\n    endpoint = f\"/lol/league/v4/entries/by-puuid/{puuid}\"\n    data = await self._make_api_call(endpoint, resolved_region.value)\n    entries_list: list[dict[str, Any]] = data  # type: ignore[assignment]\n    return [LeagueEntry.from_api_response(entry) for entry in entries_list]\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_match","title":"<code>get_match(match_id, region=None)</code>  <code>async</code>","text":"<p>Get match details by match ID.</p> <p>Parameters:</p> Name Type Description Default <code>match_id</code> <code>str</code> <p>The match ID</p> required <code>region</code> <code>Region | None</code> <p>Region to use (defaults to client's default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Match</code> <p>Match with detailed match information</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_match(self, match_id: str, region: Region | None = None) -&gt; Match:\n    \"\"\"\n    Get match details by match ID.\n\n    Args:\n        match_id: The match ID\n        region: Region to use (defaults to client's default)\n\n    Returns:\n        Match with detailed match information\n\n    \"\"\"\n    resolved_region = self._resolve_region(region)\n    endpoint = f\"/lol/match/v5/matches/{match_id}\"\n    data = await self._make_api_call(endpoint, resolved_region.v5_region)\n    return Match.from_api_response(data)\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_match_ids_by_puuid","title":"<code>get_match_ids_by_puuid(puuid, *, start_time=None, end_time=None, queue=None, match_type=None, start=0, count=20, region=None)</code>  <code>async</code>","text":"<p>Get match IDs by PUUID with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's PUUID</p> required <code>start_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match start filter</p> <code>None</code> <code>end_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match end filter</p> <code>None</code> <code>queue</code> <code>Queue | int | None</code> <p>Queue ID filter (int or QueueId enum)</p> <code>None</code> <code>match_type</code> <code>MatchType | str | None</code> <p>Match type filter (str or MatchType enum)</p> <code>None</code> <code>start</code> <code>int</code> <p>Start index (0-based)</p> <code>0</code> <code>count</code> <code>int</code> <p>Number of match IDs to return (0-100)</p> <code>20</code> <code>region</code> <code>Region | None</code> <p>Region to use (defaults to client's default)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of match IDs</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_match_ids_by_puuid(\n    self,\n    puuid: str,\n    *,\n    start_time: int | datetime | None = None,\n    end_time: int | datetime | None = None,\n    queue: Queue | int | None = None,\n    match_type: MatchType | str | None = None,\n    start: int = 0,\n    count: int = 20,\n    region: Region | None = None,\n) -&gt; list[str]:\n    \"\"\"\n    Get match IDs by PUUID with optional filters.\n\n    Args:\n        puuid: The player's PUUID\n        start_time: Epoch timestamp in seconds or datetime for match start filter\n        end_time: Epoch timestamp in seconds or datetime for match end filter\n        queue: Queue ID filter (int or QueueId enum)\n        match_type: Match type filter (str or MatchType enum)\n        start: Start index (0-based)\n        count: Number of match IDs to return (0-100)\n        region: Region to use (defaults to client's default)\n\n    Returns:\n        List of match IDs\n\n    \"\"\"\n    if not 0 &lt;= count &lt;= MAX_MATCH_ID_COUNT:\n        msg = f\"count must be between 0 and {MAX_MATCH_ID_COUNT}\"\n        raise ValueError(msg)\n\n    resolved_region = self._resolve_region(region)\n    params = self._build_match_ids_params(start_time, end_time, queue, match_type, start, count)\n    endpoint = f\"/lol/match/v5/matches/by-puuid/{puuid}/ids\"\n    data = await self._make_api_call(endpoint, resolved_region.v5_region, params=params)\n    match_ids: list[str] = data  # type: ignore[assignment]\n    return match_ids\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_player","title":"<code>get_player(game_name, tag_line, region=None)</code>  <code>async</code>","text":"<p>Create a Player object for convenient high-level access.</p> <p>Parameters:</p> Name Type Description Default <code>game_name</code> <code>str</code> <p>Player's game name (without #)</p> required <code>tag_line</code> <code>str</code> <p>Player's tag line (without #)</p> required <code>region</code> <code>Region | None</code> <p>The player's region (defaults to client default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Player</code> <p>Player object providing high-level access to player data</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_player(\n    self,\n    game_name: str,\n    tag_line: str,\n    region: Region | None = None,\n) -&gt; \"Player\":\n    \"\"\"\n    Create a Player object for convenient high-level access.\n\n    Args:\n        game_name: Player's game name (without #)\n        tag_line: Player's tag line (without #)\n        region: The player's region (defaults to client default)\n\n    Returns:\n        Player object providing high-level access to player data\n\n    \"\"\"\n    from .models.player import Player\n\n    resolved_region = self._resolve_region(region)\n\n    return await Player.create(\n        client=self,\n        game_name=game_name,\n        tag_line=tag_line,\n        region=resolved_region,\n    )\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_players","title":"<code>get_players(riot_ids, region=None)</code>  <code>async</code>","text":"<p>Create multiple Player objects efficiently using parallel processing.</p> <p>Parameters:</p> Name Type Description Default <code>riot_ids</code> <code>list[str]</code> <p>List of Riot IDs in \"username#tagline\" format.</p> required <code>region</code> <code>Region | None</code> <p>The players' region (defaults to client default)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>List of Player objects.</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_players(\n    self,\n    riot_ids: list[str],\n    region: Region | None = None,\n) -&gt; list[\"Player\"]:\n    \"\"\"\n    Create multiple Player objects efficiently using parallel processing.\n\n    Args:\n        riot_ids: List of Riot IDs in \"username#tagline\" format.\n        region: The players' region (defaults to client default)\n\n    Returns:\n        List of Player objects.\n\n    \"\"\"\n    from .models.player import Player\n\n    resolved_region = self._resolve_region(region)\n\n    async def create_player(riot_id: str) -&gt; Player:\n        return await Player.by_riot_id(\n            client=self,\n            riot_id=riot_id,\n            region=resolved_region,\n        )\n\n    return await asyncio.gather(*[create_player(riot_id) for riot_id in riot_ids])\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_riot_account","title":"<code>get_riot_account(game_name, tag_line, region=None)</code>  <code>async</code>","text":"<p>Get a Riot account by game name and tag line.</p> <p>Parameters:</p> Name Type Description Default <code>game_name</code> <code>str</code> <p>The game name (without #)</p> required <code>tag_line</code> <code>str</code> <p>The tag line (without #)</p> required <code>region</code> <code>Region | None</code> <p>Region to use (defaults to client's default)</p> <code>None</code> <p>Returns:</p> Type Description <code>RiotAccount</code> <p>RiotAccount with account information</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_riot_account(\n    self,\n    game_name: str,\n    tag_line: str,\n    region: Region | None = None,\n) -&gt; RiotAccount:\n    \"\"\"\n    Get a Riot account by game name and tag line.\n\n    Args:\n        game_name: The game name (without #)\n        tag_line: The tag line (without #)\n        region: Region to use (defaults to client's default)\n\n    Returns:\n        RiotAccount with account information\n\n    \"\"\"\n    resolved_region = self._resolve_region(region)\n    endpoint = f\"/riot/account/v1/accounts/by-riot-id/{game_name}/{tag_line}\"\n    data = await self._make_api_call(endpoint, resolved_region.account_region)\n    return RiotAccount.from_api_response(data)\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.get_summoner_by_puuid","title":"<code>get_summoner_by_puuid(puuid, region=None)</code>  <code>async</code>","text":"<p>Get a summoner by PUUID.</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The summoner's PUUID</p> required <code>region</code> <code>Region | None</code> <p>Region to use (defaults to client's default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Summoner</code> <p>Summoner with summoner information</p> Source code in <code>nexar/client.py</code> <pre><code>async def get_summoner_by_puuid(self, puuid: str, region: Region | None = None) -&gt; Summoner:\n    \"\"\"\n    Get a summoner by PUUID.\n\n    Args:\n        puuid: The summoner's PUUID\n        region: Region to use (defaults to client's default)\n\n    Returns:\n        Summoner with summoner information\n\n    \"\"\"\n    resolved_region = self._resolve_region(region)\n    endpoint = f\"/lol/summoner/v4/summoners/by-puuid/{puuid}\"\n    data = await self._make_api_call(endpoint, resolved_region.value)\n    return Summoner.from_api_response(data)\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.print_api_call_summary","title":"<code>print_api_call_summary()</code>","text":"<p>Print a summary of API calls made so far.</p> Source code in <code>nexar/client.py</code> <pre><code>def print_api_call_summary(self) -&gt; None:\n    \"\"\"Print a summary of API calls made so far.\"\"\"\n    self._logger.log_stats_summary()\n</code></pre>"},{"location":"reference/client/#nexar.client.NexarClient.reset_rate_limiter","title":"<code>reset_rate_limiter()</code>","text":"<p>Reset the rate limiter state to the initial configuration.</p> Source code in <code>nexar/client.py</code> <pre><code>def reset_rate_limiter(self) -&gt; None:\n    \"\"\"Reset the rate limiter state to the initial configuration.\"\"\"\n    self.rate_limiter = RateLimiter(\n        per_second_limit=self._per_second_limit,\n        per_minute_limit=self._per_minute_limit,\n    )\n</code></pre>"},{"location":"reference/models/match/","title":"Match","text":"<p>Represents a complete match.</p> Source code in <code>nexar/models/match/match.py</code> <pre><code>@dataclass(frozen=True)\nclass Match:\n    \"\"\"Represents a complete match.\"\"\"\n\n    metadata: MatchMetadata\n    \"\"\"Match metadata including match ID and participant list.\"\"\"\n\n    info: MatchInfo\n    \"\"\"Detailed match information including participants and teams.\"\"\"\n\n    @property\n    def participants(self) -&gt; \"ParticipantList\":\n        \"\"\"Get all participants in the match.\"\"\"\n        return self.info.participants\n\n    def __iter__(self) -&gt; Iterator[\"Participant\"]:\n        \"\"\"Allow iteration over participants.\"\"\"\n        return iter(self.participants)\n\n    @classmethod\n    def from_api_response(cls, data: dict[str, Any]) -&gt; \"Match\":\n        \"\"\"Create Match from API response.\"\"\"\n        return cls(\n            metadata=MatchMetadata.from_api_response(data[\"metadata\"]),\n            info=MatchInfo.from_api_response(data[\"info\"]),\n        )\n</code></pre>"},{"location":"reference/models/match/#nexar.models.match.Match.info","title":"<code>info</code>  <code>instance-attribute</code>","text":"<p>Detailed match information including participants and teams.</p>"},{"location":"reference/models/match/#nexar.models.match.Match.metadata","title":"<code>metadata</code>  <code>instance-attribute</code>","text":"<p>Match metadata including match ID and participant list.</p>"},{"location":"reference/models/match/#nexar.models.match.Match.participants","title":"<code>participants</code>  <code>property</code>","text":"<p>Get all participants in the match.</p>"},{"location":"reference/models/match/#nexar.models.match.Match.__iter__","title":"<code>__iter__()</code>","text":"<p>Allow iteration over participants.</p> Source code in <code>nexar/models/match/match.py</code> <pre><code>def __iter__(self) -&gt; Iterator[\"Participant\"]:\n    \"\"\"Allow iteration over participants.\"\"\"\n    return iter(self.participants)\n</code></pre>"},{"location":"reference/models/match/#nexar.models.match.Match.from_api_response","title":"<code>from_api_response(data)</code>  <code>classmethod</code>","text":"<p>Create Match from API response.</p> Source code in <code>nexar/models/match/match.py</code> <pre><code>@classmethod\ndef from_api_response(cls, data: dict[str, Any]) -&gt; \"Match\":\n    \"\"\"Create Match from API response.\"\"\"\n    return cls(\n        metadata=MatchMetadata.from_api_response(data[\"metadata\"]),\n        info=MatchInfo.from_api_response(data[\"info\"]),\n    )\n</code></pre>"},{"location":"reference/models/participant-list/","title":"ParticipantList","text":"<p>               Bases: <code>list['Participant']</code></p> <p>A specialized list for match participants with ergonomic filtering methods.</p> <p>Extends the built-in list while providing convenient methods for common participant queries and filters.</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>class ParticipantList(list[\"Participant\"]):\n    \"\"\"\n    A specialized list for match participants with ergonomic filtering methods.\n\n    Extends the built-in list while providing convenient methods for common\n    participant queries and filters.\n    \"\"\"\n\n    def by_puuid(self, puuid: str) -&gt; \"Participant | None\":\n        \"\"\"\n        Find a participant by their PUUID.\n\n        Args:\n            puuid: The player's universally unique identifier\n\n        Returns:\n            The participant with the matching PUUID, or None if not found\n\n        \"\"\"\n        return next((p for p in self if p.puuid == puuid), None)\n\n    def by_champion(self, champion_name: str) -&gt; \"ParticipantList\":\n        \"\"\"\n        Filter participants by champion name.\n\n        Args:\n            champion_name: The champion name (case-insensitive)\n\n        Returns:\n            A new ParticipantList containing participants playing the specified champion\n\n        \"\"\"\n        return ParticipantList(p for p in self if p.champion_name.lower() == champion_name.lower())\n\n    def by_position(self, position: MatchParticipantPosition) -&gt; \"ParticipantList\":\n        \"\"\"\n        Filter participants by their team position.\n\n        Args:\n            position: The position to filter by\n\n        Returns:\n            A new ParticipantList containing participants in the specified position\n\n        \"\"\"\n        return ParticipantList(p for p in self if p.team_position == position)\n\n    def by_team(self, team_id: int) -&gt; \"ParticipantList\":\n        \"\"\"\n        Filter participants by team ID.\n\n        Args:\n            team_id: The team ID (100 for blue, 200 for red)\n\n        Returns:\n            A new ParticipantList containing participants on the specified team\n\n        \"\"\"\n        return ParticipantList(p for p in self if p.team_id == team_id)\n\n    def blue_team(self) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get all participants on the blue team.\n\n        Returns:\n            A new ParticipantList containing blue team participants\n\n        \"\"\"\n        return self.by_team(100)\n\n    def red_team(self) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get all participants on the red team.\n\n        Returns:\n            A new ParticipantList containing red team participants\n\n        \"\"\"\n        return self.by_team(200)\n\n    def winners(self) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get all participants who won the match.\n\n        Returns:\n            A new ParticipantList containing winning participants\n\n        \"\"\"\n        return ParticipantList(p for p in self if p.win)\n\n    def losers(self) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get all participants who lost the match.\n\n        Returns:\n            A new ParticipantList containing losing participants\n\n        \"\"\"\n        return ParticipantList(p for p in self if not p.win)\n\n    def team_of(self, puuid: str) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get the team of the participant with the given PUUID.\n\n        Args:\n            puuid: The player's universally unique identifier\n\n        Returns:\n            A ParticipantList containing all participants on the same team as the specified PUUID.\n\n        Raises:\n            ValueError: If no participant with the given PUUID is found.\n\n        \"\"\"\n        participant = self.by_puuid(puuid)\n        if participant is None:\n            msg = f\"No participant found with PUUID: {puuid}\"\n            raise ValueError(msg)\n        return self.by_team(participant.team_id)\n\n    def filter(self, predicate: Callable[[\"Participant\"], bool]) -&gt; \"ParticipantList\":\n        \"\"\"\n        Filter participants using a custom predicate function.\n\n        Args:\n            predicate: A function that takes a Participant and returns True/False\n\n        Returns:\n            A new ParticipantList containing participants that match the predicate\n\n        \"\"\"\n        return ParticipantList(p for p in self if predicate(p))\n\n    def sort_by(\n        self,\n        key: Callable[[\"Participant\"], Any],\n        *,\n        reverse: bool = False,\n    ) -&gt; \"ParticipantList\":\n        \"\"\"\n        Sort participants by a custom key function.\n\n        Args:\n            key: A function that takes a Participant and returns a sortable value\n            reverse: Whether to sort in descending order\n\n        Returns:\n            A new ParticipantList with participants sorted by the key\n\n        \"\"\"\n        return ParticipantList(sorted(self, key=key, reverse=reverse))\n\n    def highest_kda(self, count: int = 1) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get participants with the highest KDA ratios.\n\n        Args:\n            count: Number of top participants to return\n\n        Returns:\n            A new ParticipantList with the highest KDA participants\n\n        \"\"\"\n\n        def kda_ratio(participant: \"Participant\") -&gt; float:\n            if participant.deaths == 0:\n                return float(participant.kills + participant.assists)\n            return (participant.kills + participant.assists) / participant.deaths\n\n        return ParticipantList(self.sort_by(kda_ratio, reverse=True)[:count])\n\n    def most_kills(self, count: int = 1) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get participants with the most kills.\n\n        Args:\n            count: Number of top participants to return\n\n        Returns:\n            A new ParticipantList with the most kills\n\n        \"\"\"\n        return ParticipantList(self.sort_by(lambda p: p.kills, reverse=True)[:count])\n\n    def most_damage(self, count: int = 1) -&gt; \"ParticipantList\":\n        \"\"\"\n        Get participants who dealt the most damage to champions.\n\n        Args:\n            count: Number of top participants to return\n\n        Returns:\n            A new ParticipantList with the highest damage dealers\n\n        \"\"\"\n        return ParticipantList(self.sort_by(lambda p: p.total_damage_dealt_to_champions, reverse=True)[:count])\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; \"Participant\": ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; \"ParticipantList\": ...\n\n    def __getitem__(self, key: SupportsIndex | slice) -&gt; \"Participant | ParticipantList\":\n        result = super().__getitem__(key)\n        if isinstance(key, slice):\n            msg = \"Slicing a ParticipantList did not return a list as expected.\"\n            if not isinstance(result, list):\n                raise TypeError(msg)\n            return ParticipantList(result)\n        # Defensive: ensure only a Participant is returned for int\n        if not isinstance(result, self._participant_type()):\n            msg = \"Indexing a ParticipantList did not return a Participant as expected.\"\n            raise TypeError(msg)\n        return cast(\"Participant\", result)\n\n    @staticmethod\n    def _participant_type() -&gt; type:\n        from .participant import Participant\n\n        return Participant\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.blue_team","title":"<code>blue_team()</code>","text":"<p>Get all participants on the blue team.</p> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing blue team participants</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def blue_team(self) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get all participants on the blue team.\n\n    Returns:\n        A new ParticipantList containing blue team participants\n\n    \"\"\"\n    return self.by_team(100)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.by_champion","title":"<code>by_champion(champion_name)</code>","text":"<p>Filter participants by champion name.</p> <p>Parameters:</p> Name Type Description Default <code>champion_name</code> <code>str</code> <p>The champion name (case-insensitive)</p> required <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing participants playing the specified champion</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def by_champion(self, champion_name: str) -&gt; \"ParticipantList\":\n    \"\"\"\n    Filter participants by champion name.\n\n    Args:\n        champion_name: The champion name (case-insensitive)\n\n    Returns:\n        A new ParticipantList containing participants playing the specified champion\n\n    \"\"\"\n    return ParticipantList(p for p in self if p.champion_name.lower() == champion_name.lower())\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.by_position","title":"<code>by_position(position)</code>","text":"<p>Filter participants by their team position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>MatchParticipantPosition</code> <p>The position to filter by</p> required <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing participants in the specified position</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def by_position(self, position: MatchParticipantPosition) -&gt; \"ParticipantList\":\n    \"\"\"\n    Filter participants by their team position.\n\n    Args:\n        position: The position to filter by\n\n    Returns:\n        A new ParticipantList containing participants in the specified position\n\n    \"\"\"\n    return ParticipantList(p for p in self if p.team_position == position)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.by_puuid","title":"<code>by_puuid(puuid)</code>","text":"<p>Find a participant by their PUUID.</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's universally unique identifier</p> required <p>Returns:</p> Type Description <code>Participant | None</code> <p>The participant with the matching PUUID, or None if not found</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def by_puuid(self, puuid: str) -&gt; \"Participant | None\":\n    \"\"\"\n    Find a participant by their PUUID.\n\n    Args:\n        puuid: The player's universally unique identifier\n\n    Returns:\n        The participant with the matching PUUID, or None if not found\n\n    \"\"\"\n    return next((p for p in self if p.puuid == puuid), None)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.by_team","title":"<code>by_team(team_id)</code>","text":"<p>Filter participants by team ID.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>int</code> <p>The team ID (100 for blue, 200 for red)</p> required <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing participants on the specified team</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def by_team(self, team_id: int) -&gt; \"ParticipantList\":\n    \"\"\"\n    Filter participants by team ID.\n\n    Args:\n        team_id: The team ID (100 for blue, 200 for red)\n\n    Returns:\n        A new ParticipantList containing participants on the specified team\n\n    \"\"\"\n    return ParticipantList(p for p in self if p.team_id == team_id)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.filter","title":"<code>filter(predicate)</code>","text":"<p>Filter participants using a custom predicate function.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[Participant], bool]</code> <p>A function that takes a Participant and returns True/False</p> required <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing participants that match the predicate</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def filter(self, predicate: Callable[[\"Participant\"], bool]) -&gt; \"ParticipantList\":\n    \"\"\"\n    Filter participants using a custom predicate function.\n\n    Args:\n        predicate: A function that takes a Participant and returns True/False\n\n    Returns:\n        A new ParticipantList containing participants that match the predicate\n\n    \"\"\"\n    return ParticipantList(p for p in self if predicate(p))\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.highest_kda","title":"<code>highest_kda(count=1)</code>","text":"<p>Get participants with the highest KDA ratios.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of top participants to return</p> <code>1</code> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList with the highest KDA participants</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def highest_kda(self, count: int = 1) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get participants with the highest KDA ratios.\n\n    Args:\n        count: Number of top participants to return\n\n    Returns:\n        A new ParticipantList with the highest KDA participants\n\n    \"\"\"\n\n    def kda_ratio(participant: \"Participant\") -&gt; float:\n        if participant.deaths == 0:\n            return float(participant.kills + participant.assists)\n        return (participant.kills + participant.assists) / participant.deaths\n\n    return ParticipantList(self.sort_by(kda_ratio, reverse=True)[:count])\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.losers","title":"<code>losers()</code>","text":"<p>Get all participants who lost the match.</p> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing losing participants</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def losers(self) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get all participants who lost the match.\n\n    Returns:\n        A new ParticipantList containing losing participants\n\n    \"\"\"\n    return ParticipantList(p for p in self if not p.win)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.most_damage","title":"<code>most_damage(count=1)</code>","text":"<p>Get participants who dealt the most damage to champions.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of top participants to return</p> <code>1</code> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList with the highest damage dealers</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def most_damage(self, count: int = 1) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get participants who dealt the most damage to champions.\n\n    Args:\n        count: Number of top participants to return\n\n    Returns:\n        A new ParticipantList with the highest damage dealers\n\n    \"\"\"\n    return ParticipantList(self.sort_by(lambda p: p.total_damage_dealt_to_champions, reverse=True)[:count])\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.most_kills","title":"<code>most_kills(count=1)</code>","text":"<p>Get participants with the most kills.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of top participants to return</p> <code>1</code> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList with the most kills</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def most_kills(self, count: int = 1) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get participants with the most kills.\n\n    Args:\n        count: Number of top participants to return\n\n    Returns:\n        A new ParticipantList with the most kills\n\n    \"\"\"\n    return ParticipantList(self.sort_by(lambda p: p.kills, reverse=True)[:count])\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.red_team","title":"<code>red_team()</code>","text":"<p>Get all participants on the red team.</p> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing red team participants</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def red_team(self) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get all participants on the red team.\n\n    Returns:\n        A new ParticipantList containing red team participants\n\n    \"\"\"\n    return self.by_team(200)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.sort_by","title":"<code>sort_by(key, *, reverse=False)</code>","text":"<p>Sort participants by a custom key function.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[Participant], Any]</code> <p>A function that takes a Participant and returns a sortable value</p> required <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order</p> <code>False</code> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList with participants sorted by the key</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def sort_by(\n    self,\n    key: Callable[[\"Participant\"], Any],\n    *,\n    reverse: bool = False,\n) -&gt; \"ParticipantList\":\n    \"\"\"\n    Sort participants by a custom key function.\n\n    Args:\n        key: A function that takes a Participant and returns a sortable value\n        reverse: Whether to sort in descending order\n\n    Returns:\n        A new ParticipantList with participants sorted by the key\n\n    \"\"\"\n    return ParticipantList(sorted(self, key=key, reverse=reverse))\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.team_of","title":"<code>team_of(puuid)</code>","text":"<p>Get the team of the participant with the given PUUID.</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's universally unique identifier</p> required <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A ParticipantList containing all participants on the same team as the specified PUUID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no participant with the given PUUID is found.</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def team_of(self, puuid: str) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get the team of the participant with the given PUUID.\n\n    Args:\n        puuid: The player's universally unique identifier\n\n    Returns:\n        A ParticipantList containing all participants on the same team as the specified PUUID.\n\n    Raises:\n        ValueError: If no participant with the given PUUID is found.\n\n    \"\"\"\n    participant = self.by_puuid(puuid)\n    if participant is None:\n        msg = f\"No participant found with PUUID: {puuid}\"\n        raise ValueError(msg)\n    return self.by_team(participant.team_id)\n</code></pre>"},{"location":"reference/models/participant-list/#nexar.models.match.participant_list.ParticipantList.winners","title":"<code>winners()</code>","text":"<p>Get all participants who won the match.</p> <p>Returns:</p> Type Description <code>ParticipantList</code> <p>A new ParticipantList containing winning participants</p> Source code in <code>nexar/models/match/participant_list.py</code> <pre><code>def winners(self) -&gt; \"ParticipantList\":\n    \"\"\"\n    Get all participants who won the match.\n\n    Returns:\n        A new ParticipantList containing winning participants\n\n    \"\"\"\n    return ParticipantList(p for p in self if p.win)\n</code></pre>"},{"location":"reference/models/player/","title":"Player","text":"<p>High-level player object for convenient access to player data.</p> <p>This class provides a convenient interface for accessing player data across multiple API endpoints. The riot account data is fetched immediately during creation, while other data is fetched lazily and cached within the object to avoid repeated API calls.</p> Source code in <code>nexar/models/player.py</code> <pre><code>@dataclass\nclass Player:\n    \"\"\"\n    High-level player object for convenient access to player data.\n\n    This class provides a convenient interface for accessing player data\n    across multiple API endpoints. The riot account data is fetched immediately\n    during creation, while other data is fetched lazily and cached within the\n    object to avoid repeated API calls.\n    \"\"\"\n\n    client: NexarClient\n    \"\"\"The client instance to use for API calls.\"\"\"\n\n    game_name: str\n    \"\"\"Player's game name (without #).\"\"\"\n\n    tag_line: str\n    \"\"\"Player's tag line (without #).\"\"\"\n\n    riot_account: RiotAccount\n    \"\"\"The player's Riot account information.\"\"\"\n\n    region: Region | None = None\n    \"\"\"The player's region (defaults to client default).\"\"\"\n\n    # Cached data (set after first fetch)\n    _summoner: Summoner | None = None\n    _league_entries: list[LeagueEntry] | None = None\n\n    @classmethod\n    async def create(\n        cls,\n        client: NexarClient,\n        game_name: str,\n        tag_line: str,\n        *,\n        region: Region | None = None,\n    ) -&gt; Player:\n        \"\"\"\n        Create a Player instance and fetch the riot account data immediately.\n\n        Args:\n            client: The client instance to use for API calls\n            game_name: Player's game name (without #)\n            tag_line: Player's tag line (without #)\n            region: The player's region (defaults to client default)\n\n        Returns:\n            Player instance with riot account data pre-fetched\n\n        \"\"\"\n        riot_account = await client.get_riot_account(\n            game_name,\n            tag_line,\n            region=region,\n        )\n\n        return cls(\n            client=client,\n            game_name=game_name,\n            tag_line=tag_line,\n            riot_account=riot_account,\n            region=region,\n        )\n\n    @classmethod\n    async def by_riot_id(\n        cls,\n        client: NexarClient,\n        riot_id: str,\n        *,\n        region: Region | None = None,\n    ) -&gt; Player:\n        \"\"\"\n        Create a Player instance from a Riot ID in \"username#tagline\" format.\n\n        Args:\n            client: The client instance to use for API calls\n            riot_id: Riot ID in \"username#tagline\" format (e.g., \"bexli#bex\")\n            region: The player's region (defaults to client default)\n\n        Returns:\n            Player instance with riot account data pre-fetched\n\n        Raises:\n            ValueError: If riot_id is not in the correct format\n\n        \"\"\"\n        if \"#\" not in riot_id:\n            msg = f\"Invalid Riot ID format: '{riot_id}'. Expected 'username#tagline'\"\n            raise ValueError(msg)\n\n        game_name, tag_line = riot_id.split(\"#\", 1)\n\n        if not game_name or not tag_line:\n            msg = f\"Invalid Riot ID format: '{riot_id}'. Both username and tagline must be non-empty\"\n            raise ValueError(msg)\n\n        return await cls.create(\n            client=client,\n            game_name=game_name,\n            tag_line=tag_line,\n            region=region,\n        )\n\n    async def get_summoner(self) -&gt; Summoner:\n        \"\"\"\n        Get the player's summoner information.\n\n        Returns:\n            Summoner with summoner information\n\n        \"\"\"\n        if self._summoner is None:\n            self._summoner = await self.client.get_summoner_by_puuid(\n                self.riot_account.puuid,\n                region=self.region,\n            )\n        return self._summoner\n\n    async def get_league_entries(self) -&gt; list[LeagueEntry]:\n        \"\"\"\n        Get the player's league entries.\n\n        Returns:\n            List of league entries for the player\n\n        \"\"\"\n        if self._league_entries is None:\n            self._league_entries = await self.client.get_league_entries_by_puuid(\n                self.riot_account.puuid,\n                region=self.region,\n            )\n        return self._league_entries\n\n    async def get_match_ids(\n        self,\n        *,\n        start_time: int | datetime | None = None,\n        end_time: int | datetime | None = None,\n        queue: Queue | int | None = None,\n        match_type: MatchType | str | None = None,\n        start: int = 0,\n        count: int = 20,\n    ) -&gt; list[str]:\n        \"\"\"\n        Get match IDs for the player.\n\n        Args:\n            start_time: Epoch timestamp in seconds or datetime for match start filter\n            end_time: Epoch timestamp in seconds or datetime for match end filter\n            queue: Queue ID filter (int or QueueId enum)\n            match_type: Match type filter (str or MatchType enum)\n            start: Start index (0-based)\n            count: Number of match IDs to return (0-100)\n\n        Returns:\n            List of match IDs\n\n        \"\"\"\n        return await self.client.get_match_ids_by_puuid(\n            self.riot_account.puuid,\n            start_time=start_time,\n            end_time=end_time,\n            queue=queue,\n            match_type=match_type,\n            start=start,\n            count=count,\n            region=self.region,\n        )\n\n    async def get_matches(\n        self,\n        *,\n        start_time: int | datetime | None = None,\n        end_time: int | datetime | None = None,\n        queue: Queue | int | None = None,\n        match_type: MatchType | str | None = None,\n        start: int = 0,\n        count: int = 20,\n    ) -&gt; MatchList:\n        \"\"\"\n        Get match details for the player.\n\n        Args:\n            start_time: Epoch timestamp in seconds or datetime for match start filter\n            end_time: Epoch timestamp in seconds or datetime for match end filter\n            queue: Queue ID filter (int or QueueId enum)\n            match_type: Match type filter (str or MatchType enum)\n            start: Start index (0-based)\n            count: Number of match IDs to return (0-100)\n\n        Returns:\n            MatchList of Match objects with detailed match information\n\n        \"\"\"\n        match_ids = await self.get_match_ids(\n            start_time=start_time,\n            end_time=end_time,\n            queue=queue,\n            match_type=match_type,\n            start=start,\n            count=count,\n        )\n\n        matches: list[Match] = []\n        for match_id in match_ids:\n            match = await self.client.get_match(match_id, region=self.region)\n            matches.append(match)\n        return MatchList(matches, self.riot_account.puuid)\n\n    async def get_last_match(self) -&gt; Match | None:\n        \"\"\"\n        Get the player's most recent match.\n\n        Returns:\n            Most recent Match object, or None if no matches found\n\n        \"\"\"\n        match_ids = await self.get_match_ids(count=1)\n        if not match_ids:\n            return None\n\n        return await self.client.get_match(match_ids[0], region=self.region)\n\n    @property\n    def puuid(self) -&gt; str:\n        \"\"\"Get the player's PUUID.\"\"\"\n        return self.riot_account.puuid\n\n    async def get_solo_rank(self) -&gt; LeagueEntry | None:\n        \"\"\"\n        Get the player's solo queue rank.\n\n        - API queue type: RANKED_SOLO_5x5\n        - Map: Summoner's Rift\n        - Colloquial name: Solo Queue or Solo/Duo Queue\n\n        Returns:\n            LeagueEntry for solo queue, or None if unranked\n\n        \"\"\"\n        league_entries = await self.get_league_entries()\n        for entry in league_entries:\n            if entry.queue_type == Queue.RANKED_SOLO_5x5:\n                return entry\n        return None\n\n    async def get_flex_rank(self) -&gt; LeagueEntry | None:\n        \"\"\"\n        Get the player's flex queue rank.\n\n        - API queue type: RANKED_FLEX_SR\n        - Map: Summoner's Rift\n        - Colloquial name: Flex Queue\n\n        Returns:\n            LeagueEntry for flex queue, or None if unranked\n\n        \"\"\"\n        league_entries = await self.get_league_entries()\n        for entry in league_entries:\n            if entry.queue_type == Queue.RANKED_FLEX_SR:\n                return entry\n        return None\n\n    async def get_solo_rank_value(self) -&gt; tuple[int, int] | None:\n        \"\"\"\n        Combined tier/rank value for the player's solo queue rank.\n\n        Returns None if the player is unranked in solo queue.\n\n        Useful for comparing or sorting players by solo queue rank.\n\n        Returns:\n            Tuple of (rank_value, league_points), or None if unranked\n\n        \"\"\"\n        rank = await self.get_solo_rank()\n        if rank is not None:\n            return rank.rank_tuple\n        return None\n\n    async def get_top_champions(\n        self,\n        top_n: int = 5,\n        count: int = 20,\n        queue: Queue | int | None = None,\n        match_type: MatchType | str | None = None,\n    ) -&gt; list[ChampionStats]:\n        \"\"\"\n        Get top played champions.\n\n        Args:\n            top_n: Number of top champions to return (default 5)\n            count: Number of recent matches to analyze (default 20)\n            queue: Optional queue type filter\n            match_type: Optional match type filter\n\n        Returns:\n            List of ChampionStats sorted by games played (descending)\n\n        \"\"\"\n        matches = await self.get_matches(\n            queue=queue,\n            match_type=match_type,\n            count=count,\n        )\n        champion_stats = matches.get_champion_stats()\n        return sorted(champion_stats, key=lambda x: x.games_played, reverse=True)[:top_n]\n\n    async def get_recent_performance_by_role(\n        self,\n        count: int = 50,\n        queue: Queue | int | None = None,\n    ) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"\n        Get performance statistics grouped by role.\n\n        Args:\n            count: Number of recent matches to analyze (default 50)\n            queue: Optional queue type filter\n\n        Returns:\n            Dictionary with role names as keys and performance stats as values\n\n        \"\"\"\n        matches = await self.get_matches(queue=queue, count=count)\n        puuid = self.riot_account.puuid\n\n        role_stats: dict[str, dict[str, Any]] = {}\n\n        for match in matches:\n            # Find the participant for this player\n            participant = match.participants.by_puuid(puuid)\n\n            if not participant:\n                continue\n\n            role = participant.team_position.value if participant.team_position else \"UNKNOWN\"\n\n            if role not in role_stats:\n                role_stats[role] = {\n                    \"games\": 0,\n                    \"wins\": 0,\n                    \"kills\": 0,\n                    \"deaths\": 0,\n                    \"assists\": 0,\n                }\n\n            role_stats[role][\"games\"] += 1\n            if participant.win:\n                role_stats[role][\"wins\"] += 1\n            role_stats[role][\"kills\"] += participant.kills\n            role_stats[role][\"deaths\"] += participant.deaths\n            role_stats[role][\"assists\"] += participant.assists\n\n        # Calculate averages and percentages\n        for stats in role_stats.values():\n            games = stats[\"games\"]\n            if games &gt; 0:\n                stats[\"win_rate\"] = (stats[\"wins\"] / games) * 100.0\n                stats[\"avg_kills\"] = stats[\"kills\"] / games\n                stats[\"avg_deaths\"] = stats[\"deaths\"] / games\n                stats[\"avg_assists\"] = stats[\"assists\"] / games\n                stats[\"avg_kda\"] = (stats[\"kills\"] + stats[\"assists\"]) / stats[\"deaths\"] if stats[\"deaths\"] &gt; 0 else 0.0\n\n        return role_stats\n\n    async def is_on_win_streak(self, min_games: int = 3) -&gt; bool:\n        \"\"\"\n        Check if the player is currently on a win streak.\n\n        Args:\n            min_games: Minimum number of games to consider a streak (default 3)\n\n        Returns:\n            True if the player is on a win streak of at least min_games\n\n        \"\"\"\n        matches = await self.get_matches(count=min_games * 2)  # Get extra to be safe\n        puuid = self.riot_account.puuid\n\n        wins_in_a_row = 0\n        for match in matches:\n            # Find the participant for this player\n            participant = match.participants.by_puuid(puuid)\n\n            if not participant:\n                continue\n\n            if participant.win:\n                wins_in_a_row += 1\n            else:\n                break  # Streak broken\n\n        return wins_in_a_row &gt;= min_games\n\n    def refresh_cache(self) -&gt; None:\n        \"\"\"Clear all cached data to force fresh API calls.\"\"\"\n        self._summoner = None\n        self._league_entries = None\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of the player.\"\"\"\n        return f\"{self.game_name}#{self.tag_line}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the player.\"\"\"\n        return f\"Player(game_name='{self.game_name}', tag_line='{self.tag_line}')\"\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.client","title":"<code>client</code>  <code>instance-attribute</code>","text":"<p>The client instance to use for API calls.</p>"},{"location":"reference/models/player/#nexar.models.player.Player.game_name","title":"<code>game_name</code>  <code>instance-attribute</code>","text":"<p>Player's game name (without #).</p>"},{"location":"reference/models/player/#nexar.models.player.Player.puuid","title":"<code>puuid</code>  <code>property</code>","text":"<p>Get the player's PUUID.</p>"},{"location":"reference/models/player/#nexar.models.player.Player.region","title":"<code>region = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The player's region (defaults to client default).</p>"},{"location":"reference/models/player/#nexar.models.player.Player.riot_account","title":"<code>riot_account</code>  <code>instance-attribute</code>","text":"<p>The player's Riot account information.</p>"},{"location":"reference/models/player/#nexar.models.player.Player.tag_line","title":"<code>tag_line</code>  <code>instance-attribute</code>","text":"<p>Player's tag line (without #).</p>"},{"location":"reference/models/player/#nexar.models.player.Player.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation of the player.</p> Source code in <code>nexar/models/player.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the player.\"\"\"\n    return f\"Player(game_name='{self.game_name}', tag_line='{self.tag_line}')\"\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation of the player.</p> Source code in <code>nexar/models/player.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of the player.\"\"\"\n    return f\"{self.game_name}#{self.tag_line}\"\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.by_riot_id","title":"<code>by_riot_id(client, riot_id, *, region=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a Player instance from a Riot ID in \"username#tagline\" format.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NexarClient</code> <p>The client instance to use for API calls</p> required <code>riot_id</code> <code>str</code> <p>Riot ID in \"username#tagline\" format (e.g., \"bexli#bex\")</p> required <code>region</code> <code>Region | None</code> <p>The player's region (defaults to client default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Player</code> <p>Player instance with riot account data pre-fetched</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If riot_id is not in the correct format</p> Source code in <code>nexar/models/player.py</code> <pre><code>@classmethod\nasync def by_riot_id(\n    cls,\n    client: NexarClient,\n    riot_id: str,\n    *,\n    region: Region | None = None,\n) -&gt; Player:\n    \"\"\"\n    Create a Player instance from a Riot ID in \"username#tagline\" format.\n\n    Args:\n        client: The client instance to use for API calls\n        riot_id: Riot ID in \"username#tagline\" format (e.g., \"bexli#bex\")\n        region: The player's region (defaults to client default)\n\n    Returns:\n        Player instance with riot account data pre-fetched\n\n    Raises:\n        ValueError: If riot_id is not in the correct format\n\n    \"\"\"\n    if \"#\" not in riot_id:\n        msg = f\"Invalid Riot ID format: '{riot_id}'. Expected 'username#tagline'\"\n        raise ValueError(msg)\n\n    game_name, tag_line = riot_id.split(\"#\", 1)\n\n    if not game_name or not tag_line:\n        msg = f\"Invalid Riot ID format: '{riot_id}'. Both username and tagline must be non-empty\"\n        raise ValueError(msg)\n\n    return await cls.create(\n        client=client,\n        game_name=game_name,\n        tag_line=tag_line,\n        region=region,\n    )\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.create","title":"<code>create(client, game_name, tag_line, *, region=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a Player instance and fetch the riot account data immediately.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NexarClient</code> <p>The client instance to use for API calls</p> required <code>game_name</code> <code>str</code> <p>Player's game name (without #)</p> required <code>tag_line</code> <code>str</code> <p>Player's tag line (without #)</p> required <code>region</code> <code>Region | None</code> <p>The player's region (defaults to client default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Player</code> <p>Player instance with riot account data pre-fetched</p> Source code in <code>nexar/models/player.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    client: NexarClient,\n    game_name: str,\n    tag_line: str,\n    *,\n    region: Region | None = None,\n) -&gt; Player:\n    \"\"\"\n    Create a Player instance and fetch the riot account data immediately.\n\n    Args:\n        client: The client instance to use for API calls\n        game_name: Player's game name (without #)\n        tag_line: Player's tag line (without #)\n        region: The player's region (defaults to client default)\n\n    Returns:\n        Player instance with riot account data pre-fetched\n\n    \"\"\"\n    riot_account = await client.get_riot_account(\n        game_name,\n        tag_line,\n        region=region,\n    )\n\n    return cls(\n        client=client,\n        game_name=game_name,\n        tag_line=tag_line,\n        riot_account=riot_account,\n        region=region,\n    )\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_flex_rank","title":"<code>get_flex_rank()</code>  <code>async</code>","text":"<p>Get the player's flex queue rank.</p> <ul> <li>API queue type: RANKED_FLEX_SR</li> <li>Map: Summoner's Rift</li> <li>Colloquial name: Flex Queue</li> </ul> <p>Returns:</p> Type Description <code>LeagueEntry | None</code> <p>LeagueEntry for flex queue, or None if unranked</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_flex_rank(self) -&gt; LeagueEntry | None:\n    \"\"\"\n    Get the player's flex queue rank.\n\n    - API queue type: RANKED_FLEX_SR\n    - Map: Summoner's Rift\n    - Colloquial name: Flex Queue\n\n    Returns:\n        LeagueEntry for flex queue, or None if unranked\n\n    \"\"\"\n    league_entries = await self.get_league_entries()\n    for entry in league_entries:\n        if entry.queue_type == Queue.RANKED_FLEX_SR:\n            return entry\n    return None\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_last_match","title":"<code>get_last_match()</code>  <code>async</code>","text":"<p>Get the player's most recent match.</p> <p>Returns:</p> Type Description <code>Match | None</code> <p>Most recent Match object, or None if no matches found</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_last_match(self) -&gt; Match | None:\n    \"\"\"\n    Get the player's most recent match.\n\n    Returns:\n        Most recent Match object, or None if no matches found\n\n    \"\"\"\n    match_ids = await self.get_match_ids(count=1)\n    if not match_ids:\n        return None\n\n    return await self.client.get_match(match_ids[0], region=self.region)\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_league_entries","title":"<code>get_league_entries()</code>  <code>async</code>","text":"<p>Get the player's league entries.</p> <p>Returns:</p> Type Description <code>list[LeagueEntry]</code> <p>List of league entries for the player</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_league_entries(self) -&gt; list[LeagueEntry]:\n    \"\"\"\n    Get the player's league entries.\n\n    Returns:\n        List of league entries for the player\n\n    \"\"\"\n    if self._league_entries is None:\n        self._league_entries = await self.client.get_league_entries_by_puuid(\n            self.riot_account.puuid,\n            region=self.region,\n        )\n    return self._league_entries\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_match_ids","title":"<code>get_match_ids(*, start_time=None, end_time=None, queue=None, match_type=None, start=0, count=20)</code>  <code>async</code>","text":"<p>Get match IDs for the player.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match start filter</p> <code>None</code> <code>end_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match end filter</p> <code>None</code> <code>queue</code> <code>Queue | int | None</code> <p>Queue ID filter (int or QueueId enum)</p> <code>None</code> <code>match_type</code> <code>MatchType | str | None</code> <p>Match type filter (str or MatchType enum)</p> <code>None</code> <code>start</code> <code>int</code> <p>Start index (0-based)</p> <code>0</code> <code>count</code> <code>int</code> <p>Number of match IDs to return (0-100)</p> <code>20</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of match IDs</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_match_ids(\n    self,\n    *,\n    start_time: int | datetime | None = None,\n    end_time: int | datetime | None = None,\n    queue: Queue | int | None = None,\n    match_type: MatchType | str | None = None,\n    start: int = 0,\n    count: int = 20,\n) -&gt; list[str]:\n    \"\"\"\n    Get match IDs for the player.\n\n    Args:\n        start_time: Epoch timestamp in seconds or datetime for match start filter\n        end_time: Epoch timestamp in seconds or datetime for match end filter\n        queue: Queue ID filter (int or QueueId enum)\n        match_type: Match type filter (str or MatchType enum)\n        start: Start index (0-based)\n        count: Number of match IDs to return (0-100)\n\n    Returns:\n        List of match IDs\n\n    \"\"\"\n    return await self.client.get_match_ids_by_puuid(\n        self.riot_account.puuid,\n        start_time=start_time,\n        end_time=end_time,\n        queue=queue,\n        match_type=match_type,\n        start=start,\n        count=count,\n        region=self.region,\n    )\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_matches","title":"<code>get_matches(*, start_time=None, end_time=None, queue=None, match_type=None, start=0, count=20)</code>  <code>async</code>","text":"<p>Get match details for the player.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match start filter</p> <code>None</code> <code>end_time</code> <code>int | datetime | None</code> <p>Epoch timestamp in seconds or datetime for match end filter</p> <code>None</code> <code>queue</code> <code>Queue | int | None</code> <p>Queue ID filter (int or QueueId enum)</p> <code>None</code> <code>match_type</code> <code>MatchType | str | None</code> <p>Match type filter (str or MatchType enum)</p> <code>None</code> <code>start</code> <code>int</code> <p>Start index (0-based)</p> <code>0</code> <code>count</code> <code>int</code> <p>Number of match IDs to return (0-100)</p> <code>20</code> <p>Returns:</p> Type Description <code>MatchList</code> <p>MatchList of Match objects with detailed match information</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_matches(\n    self,\n    *,\n    start_time: int | datetime | None = None,\n    end_time: int | datetime | None = None,\n    queue: Queue | int | None = None,\n    match_type: MatchType | str | None = None,\n    start: int = 0,\n    count: int = 20,\n) -&gt; MatchList:\n    \"\"\"\n    Get match details for the player.\n\n    Args:\n        start_time: Epoch timestamp in seconds or datetime for match start filter\n        end_time: Epoch timestamp in seconds or datetime for match end filter\n        queue: Queue ID filter (int or QueueId enum)\n        match_type: Match type filter (str or MatchType enum)\n        start: Start index (0-based)\n        count: Number of match IDs to return (0-100)\n\n    Returns:\n        MatchList of Match objects with detailed match information\n\n    \"\"\"\n    match_ids = await self.get_match_ids(\n        start_time=start_time,\n        end_time=end_time,\n        queue=queue,\n        match_type=match_type,\n        start=start,\n        count=count,\n    )\n\n    matches: list[Match] = []\n    for match_id in match_ids:\n        match = await self.client.get_match(match_id, region=self.region)\n        matches.append(match)\n    return MatchList(matches, self.riot_account.puuid)\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_recent_performance_by_role","title":"<code>get_recent_performance_by_role(count=50, queue=None)</code>  <code>async</code>","text":"<p>Get performance statistics grouped by role.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of recent matches to analyze (default 50)</p> <code>50</code> <code>queue</code> <code>Queue | int | None</code> <p>Optional queue type filter</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>Dictionary with role names as keys and performance stats as values</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_recent_performance_by_role(\n    self,\n    count: int = 50,\n    queue: Queue | int | None = None,\n) -&gt; dict[str, dict[str, Any]]:\n    \"\"\"\n    Get performance statistics grouped by role.\n\n    Args:\n        count: Number of recent matches to analyze (default 50)\n        queue: Optional queue type filter\n\n    Returns:\n        Dictionary with role names as keys and performance stats as values\n\n    \"\"\"\n    matches = await self.get_matches(queue=queue, count=count)\n    puuid = self.riot_account.puuid\n\n    role_stats: dict[str, dict[str, Any]] = {}\n\n    for match in matches:\n        # Find the participant for this player\n        participant = match.participants.by_puuid(puuid)\n\n        if not participant:\n            continue\n\n        role = participant.team_position.value if participant.team_position else \"UNKNOWN\"\n\n        if role not in role_stats:\n            role_stats[role] = {\n                \"games\": 0,\n                \"wins\": 0,\n                \"kills\": 0,\n                \"deaths\": 0,\n                \"assists\": 0,\n            }\n\n        role_stats[role][\"games\"] += 1\n        if participant.win:\n            role_stats[role][\"wins\"] += 1\n        role_stats[role][\"kills\"] += participant.kills\n        role_stats[role][\"deaths\"] += participant.deaths\n        role_stats[role][\"assists\"] += participant.assists\n\n    # Calculate averages and percentages\n    for stats in role_stats.values():\n        games = stats[\"games\"]\n        if games &gt; 0:\n            stats[\"win_rate\"] = (stats[\"wins\"] / games) * 100.0\n            stats[\"avg_kills\"] = stats[\"kills\"] / games\n            stats[\"avg_deaths\"] = stats[\"deaths\"] / games\n            stats[\"avg_assists\"] = stats[\"assists\"] / games\n            stats[\"avg_kda\"] = (stats[\"kills\"] + stats[\"assists\"]) / stats[\"deaths\"] if stats[\"deaths\"] &gt; 0 else 0.0\n\n    return role_stats\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_solo_rank","title":"<code>get_solo_rank()</code>  <code>async</code>","text":"<p>Get the player's solo queue rank.</p> <ul> <li>API queue type: RANKED_SOLO_5x5</li> <li>Map: Summoner's Rift</li> <li>Colloquial name: Solo Queue or Solo/Duo Queue</li> </ul> <p>Returns:</p> Type Description <code>LeagueEntry | None</code> <p>LeagueEntry for solo queue, or None if unranked</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_solo_rank(self) -&gt; LeagueEntry | None:\n    \"\"\"\n    Get the player's solo queue rank.\n\n    - API queue type: RANKED_SOLO_5x5\n    - Map: Summoner's Rift\n    - Colloquial name: Solo Queue or Solo/Duo Queue\n\n    Returns:\n        LeagueEntry for solo queue, or None if unranked\n\n    \"\"\"\n    league_entries = await self.get_league_entries()\n    for entry in league_entries:\n        if entry.queue_type == Queue.RANKED_SOLO_5x5:\n            return entry\n    return None\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_solo_rank_value","title":"<code>get_solo_rank_value()</code>  <code>async</code>","text":"<p>Combined tier/rank value for the player's solo queue rank.</p> <p>Returns None if the player is unranked in solo queue.</p> <p>Useful for comparing or sorting players by solo queue rank.</p> <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>Tuple of (rank_value, league_points), or None if unranked</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_solo_rank_value(self) -&gt; tuple[int, int] | None:\n    \"\"\"\n    Combined tier/rank value for the player's solo queue rank.\n\n    Returns None if the player is unranked in solo queue.\n\n    Useful for comparing or sorting players by solo queue rank.\n\n    Returns:\n        Tuple of (rank_value, league_points), or None if unranked\n\n    \"\"\"\n    rank = await self.get_solo_rank()\n    if rank is not None:\n        return rank.rank_tuple\n    return None\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_summoner","title":"<code>get_summoner()</code>  <code>async</code>","text":"<p>Get the player's summoner information.</p> <p>Returns:</p> Type Description <code>Summoner</code> <p>Summoner with summoner information</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_summoner(self) -&gt; Summoner:\n    \"\"\"\n    Get the player's summoner information.\n\n    Returns:\n        Summoner with summoner information\n\n    \"\"\"\n    if self._summoner is None:\n        self._summoner = await self.client.get_summoner_by_puuid(\n            self.riot_account.puuid,\n            region=self.region,\n        )\n    return self._summoner\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.get_top_champions","title":"<code>get_top_champions(top_n=5, count=20, queue=None, match_type=None)</code>  <code>async</code>","text":"<p>Get top played champions.</p> <p>Parameters:</p> Name Type Description Default <code>top_n</code> <code>int</code> <p>Number of top champions to return (default 5)</p> <code>5</code> <code>count</code> <code>int</code> <p>Number of recent matches to analyze (default 20)</p> <code>20</code> <code>queue</code> <code>Queue | int | None</code> <p>Optional queue type filter</p> <code>None</code> <code>match_type</code> <code>MatchType | str | None</code> <p>Optional match type filter</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ChampionStats]</code> <p>List of ChampionStats sorted by games played (descending)</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def get_top_champions(\n    self,\n    top_n: int = 5,\n    count: int = 20,\n    queue: Queue | int | None = None,\n    match_type: MatchType | str | None = None,\n) -&gt; list[ChampionStats]:\n    \"\"\"\n    Get top played champions.\n\n    Args:\n        top_n: Number of top champions to return (default 5)\n        count: Number of recent matches to analyze (default 20)\n        queue: Optional queue type filter\n        match_type: Optional match type filter\n\n    Returns:\n        List of ChampionStats sorted by games played (descending)\n\n    \"\"\"\n    matches = await self.get_matches(\n        queue=queue,\n        match_type=match_type,\n        count=count,\n    )\n    champion_stats = matches.get_champion_stats()\n    return sorted(champion_stats, key=lambda x: x.games_played, reverse=True)[:top_n]\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.is_on_win_streak","title":"<code>is_on_win_streak(min_games=3)</code>  <code>async</code>","text":"<p>Check if the player is currently on a win streak.</p> <p>Parameters:</p> Name Type Description Default <code>min_games</code> <code>int</code> <p>Minimum number of games to consider a streak (default 3)</p> <code>3</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the player is on a win streak of at least min_games</p> Source code in <code>nexar/models/player.py</code> <pre><code>async def is_on_win_streak(self, min_games: int = 3) -&gt; bool:\n    \"\"\"\n    Check if the player is currently on a win streak.\n\n    Args:\n        min_games: Minimum number of games to consider a streak (default 3)\n\n    Returns:\n        True if the player is on a win streak of at least min_games\n\n    \"\"\"\n    matches = await self.get_matches(count=min_games * 2)  # Get extra to be safe\n    puuid = self.riot_account.puuid\n\n    wins_in_a_row = 0\n    for match in matches:\n        # Find the participant for this player\n        participant = match.participants.by_puuid(puuid)\n\n        if not participant:\n            continue\n\n        if participant.win:\n            wins_in_a_row += 1\n        else:\n            break  # Streak broken\n\n    return wins_in_a_row &gt;= min_games\n</code></pre>"},{"location":"reference/models/player/#nexar.models.player.Player.refresh_cache","title":"<code>refresh_cache()</code>","text":"<p>Clear all cached data to force fresh API calls.</p> Source code in <code>nexar/models/player.py</code> <pre><code>def refresh_cache(self) -&gt; None:\n    \"\"\"Clear all cached data to force fresh API calls.\"\"\"\n    self._summoner = None\n    self._league_entries = None\n</code></pre>"}]}